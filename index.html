<!--
HOW TO RUN:
1. Place this index.html file in the same folder as "ses_cetveli_v3.jpg"
2. Serve via a local web server (required for audio/image loading):
   - Python: python -m http.server 8000
   - Node: npx http-server
   - Or use any local server
3. Open http://localhost:8000/index.html in your browser
4. Click "Start Audio" to begin (required for autoplay policy)
5. Upload audio files (.wav/.mp3/.ogg) to sources and drag listener/sources around

NOTE: Audio files must be served from a local server due to CORS restrictions.
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sound Ruler / Noise Ruler</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@200;300;400;500&display=block" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
        }
        
        #layout {
            display: flex;
            height: 100vh;
            width: 100vw;
        }
        
        #main-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }
        
        #canvas-container {
            position: relative;
            background: #2a2a2a;
            border: 2px solid #444;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #canvas {
            display: block;
            cursor: crosshair;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        #control-panel {
            background: #2a2a2a;
            border-left: 2px solid #444;
            display: flex;
            flex-direction: column;
            width: 360px;
            transition: width 0.3s ease;
            overflow: hidden;
        }
        
        #control-panel.collapsed {
            width: 40px;
        }
        
        #control-panel.collapsed #panel-title,
        #control-panel.collapsed #tab-bar,
        #control-panel.collapsed #tab-content {
            display: none;
        }
        
        #panel-header {
            display: flex;
            align-items: center;
            padding: 8px 15px;
            background: #1a1a1a;
            border-bottom: 1px solid #444;
            cursor: pointer;
            user-select: none;
        }
        
        #control-panel.collapsed #panel-header {
            padding: 8px;
            justify-content: center;
        }
        
        #panel-header:hover {
            background: #222;
        }
        
        #collapse-toggle {
            margin-right: 10px;
            font-size: 14px;
            color: #aaa;
        }
        
        #panel-title {
            flex: 1;
            font-weight: bold;
            font-size: 14px;
        }
        
        #tab-bar {
            display: flex;
            flex-direction: column;
            background: #1a1a1a;
            border-bottom: 1px solid #444;
        }
        
        .tab {
            padding: 12px 15px;
            background: #1a1a1a;
            border: none;
            border-right: 2px solid transparent;
            color: #aaa;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            text-align: left;
        }
        
        .tab:hover {
            background: #222;
            color: #fff;
        }
        
        .tab.active {
            background: #2a2a2a;
            color: #fff;
            border-right-color: #0066cc;
        }
        
        #tab-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }
        
        .tab-pane {
            display: none;
        }
        
        .tab-pane.active {
            display: block;
        }
        
        .control-group {
            margin-bottom: 12px;
        }
        
        label {
            display: block;
            font-size: 12px;
            margin-bottom: 4px;
            color: #aaa;
        }
        
        input[type="range"] {
            width: 100%;
        }
        
        input[type="text"], input[type="number"] {
            width: 100%;
            padding: 4px 8px;
            background: #1a1a1a;
            border: 1px solid #444;
            color: #e0e0e0;
            border-radius: 3px;
            font-size: 12px;
        }
        
        input[type="file"] {
            font-size: 11px;
            margin-top: 4px;
            width: 100%;
        }
        
        .toggle {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        button {
            background: #4a4a4a;
            color: #fff;
            border: 1px solid #666;
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 13px;
        }
        
        button:hover {
            background: #5a5a5a;
        }
        
        button:active {
            background: #3a3a3a;
        }
        
        button.primary {
            background: #0066cc;
            border-color: #0088ff;
        }
        
        button.primary:hover {
            background: #0077dd;
        }
        
        button.danger {
            background: #cc3300;
            border-color: #ff4400;
        }
        
        button.danger:hover {
            background: #dd4400;
        }
        
        .source-item {
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 3px;
            padding: 10px;
            margin-bottom: 8px;
        }
        
        .source-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .source-name {
            font-weight: bold;
            font-size: 13px;
            color: #fff;
            flex: 1;
        }
        
        .source-controls {
            display: flex;
            gap: 5px;
        }
        
        .source-controls button {
            padding: 3px 8px;
            font-size: 11px;
        }
        
        .source-info {
            font-size: 11px;
            color: #aaa;
            margin-bottom: 5px;
        }
        
        .active-source {
            border-color: #0066cc;
            background: #1a2a3a;
        }
        
        .readout {
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 3px;
            padding: 8px;
            font-size: 11px;
            font-family: 'Courier New', monospace;
            color: #0f0;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .status {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 2px;
            font-size: 10px;
            font-weight: bold;
            margin-left: 5px;
        }
        
        .status.stopped {
            background: #cc3300;
            color: #fff;
        }
        
        .status.playing {
            background: #00cc33;
            color: #fff;
        }
        
        .button-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        #audio-hud {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(26, 26, 26, 0.95);
            border: 2px solid #444;
            border-radius: 4px;
            padding: 6px 10px;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        }
        
        #audio-hud .hud-controls {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        
        #audio-hud button {
            padding: 4px 10px;
            font-size: 10px;
        }
        
        #audio-hud .hud-status {
            font-size: 9px;
            font-weight: bold;
            padding: 3px 8px;
            border-radius: 3px;
            min-width: 55px;
            text-align: center;
        }
        
        #audio-hud .hud-status.playing {
            background: #00cc33;
            color: #fff;
        }
        
        #audio-hud .hud-status.stopped {
            background: #cc3300;
            color: #fff;
        }
        
        
        #debug-overlay {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(26, 26, 26, 0.9);
            border: 1px solid #444;
            border-radius: 3px;
            padding: 6px 10px;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            color: #0f0;
            z-index: 999;
            line-height: 1.4;
            display: none; /* Default: hidden, can be shown via control panel */
        }
        
        #debug-overlay.visible {
            display: block;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
    </style>
</head>
<body>
    <div id="debug-overlay">
        <div>bgState: <span id="debug-bgState">-</span></div>
        <div>bgSrc: <span id="debug-bgSrc">-</span></div>
        <div>scale: <span id="debug-scale">-</span></div>
        <div>canvasPixelSize: <span id="debug-canvasSize">-</span></div>
        <div>framesDrawn: <span id="debug-frames">0</span></div>
    </div>
    
    <div id="audio-hud">
        <div class="hud-controls">
            <button id="hudStartBtn" class="primary">Start</button>
            <button id="hudStopBtn">Stop</button>
        </div>
        <div id="hudStatus" class="hud-status stopped">STOPPED</div>
    </div>
    
    <div id="layout">
        <div id="main-container">
            <div id="canvas-container">
                <canvas id="canvas" width="240" height="240"></canvas>
            </div>
        </div>
        
        <div id="control-panel">
        <div id="panel-header">
            <span id="collapse-toggle">◀</span>
            <span id="panel-title">Controls</span>
        </div>
        <div id="tab-bar">
            <button class="tab active" data-tab="audio">Audio</button>
            <button class="tab" data-tab="sources">Sources</button>
            <button class="tab" data-tab="mixer">Mixer</button>
            <button class="tab" data-tab="view">View</button>
            <button class="tab" data-tab="rings">Rings</button>
            <button class="tab" data-tab="debug">Debug</button>
        </div>
        <div id="tab-content">
            <div id="tab-audio" class="tab-pane active">
                <div class="control-group">
                    <label>Nearest N Sources: <span id="nearestNValue">4</span></label>
                    <input type="range" id="nearestN" min="1" max="8" value="4" step="1">
                </div>
                <div class="control-group">
                    <label>Global Rmax: <span id="globalRmaxValue">80</span></label>
                    <input type="range" id="globalRmax" min="20" max="200" value="80" step="5">
                </div>
                <div class="control-group">
                    <label>Falloff Power: <span id="falloffPowerValue">2.2</span></label>
                    <input type="range" id="falloffPower" min="0.5" max="5" value="2.2" step="0.1">
                </div>
                <div class="control-group toggle">
                    <input type="checkbox" id="panningEnabled" checked>
                    <label for="panningEnabled">Stereo Panning</label>
                </div>
                <div class="control-group">
                    <label>Pan Distance: <span id="panDistanceValue">120</span></label>
                    <input type="range" id="panDistance" min="50" max="240" value="120" step="5">
                </div>
            </div>
            
            <div id="tab-sources" class="tab-pane">
                <div class="control-group">
                    <label>Load Audio Files:</label>
                    <input type="file" id="loadAllAudioFiles" accept="audio/*" multiple style="margin-bottom: 5px;">
                    <div style="font-size: 10px; color: #888; margin-top: 4px;">
                        <strong>Option 1 (file://):</strong> Select multiple audio files (A1.mp3, A2.wav, etc.) to auto-match with sources. Files are saved to localStorage.
                        <br><br>
                        <strong>Option 2 (Recommended - Auto-load on startup):</strong> Use a local server:
                        <br>1. Open terminal in this folder
                        <br>2. Run: <code style="background: #1a1a1a; padding: 2px 4px; border-radius: 2px; font-family: monospace;">python -m http.server 8000</code>
                        <br>3. Open: <code style="background: #1a1a1a; padding: 2px 4px; border-radius: 2px; font-family: monospace;">http://localhost:8000/index.html</code>
                        <br>Files named A1.mp3, A2.wav, etc. will auto-load on startup!
                    </div>
                </div>
                <button id="addSourceBtn" style="margin-bottom: 10px; width: 100%;">Add Source</button>
                <div id="sourcesList"></div>
            </div>
            
            <div id="tab-mixer" class="tab-pane">
                <div id="mixerList" style="max-height: 300px; overflow-y: auto;">
                    <!-- Mixer list will be populated here -->
                </div>
                <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #444;">
                    <div style="margin-bottom: 12px; font-size: 12px; color: #ccc; font-weight: bold;">Compressor</div>
                    <div class="control-group">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="compressorEnabled" checked style="margin-right: 8px;">
                            <span>Enable Compressor</span>
                        </label>
                    </div>
                    <div class="control-group">
                        <label>Threshold: <span id="compressorThresholdValue">-25</span> dB</label>
                        <input type="range" id="compressorThreshold" min="-40" max="0" value="-25" step="1">
                    </div>
                    <div class="control-group">
                        <label>Ratio: <span id="compressorRatioValue">1.5</span>:1</label>
                        <input type="range" id="compressorRatio" min="1" max="20" value="1.5" step="0.5">
                    </div>
                    <div class="control-group">
                        <label>Attack: <span id="compressorAttackValue">50</span> ms</label>
                        <input type="range" id="compressorAttack" min="0" max="100" value="50" step="1">
                    </div>
                    <div class="control-group">
                        <label>Release: <span id="compressorReleaseValue">340</span> ms</label>
                        <input type="range" id="compressorRelease" min="0" max="1000" value="340" step="10">
                    </div>
                    <div class="control-group">
                        <label>Makeup Gain: <span id="compressorMakeupValue">3</span> dB</label>
                        <input type="range" id="compressorMakeup" min="0" max="12" value="3" step="0.5">
                    </div>
                    <div style="margin-top: 15px; margin-bottom: 8px; font-size: 11px; color: #ccc;">Gain Reduction</div>
                    <div id="gainReductionMeter" style="width: 100%; height: 20px; background: #1a1a1a; border: 1px solid #444; border-radius: 3px; position: relative; overflow: hidden;">
                        <div id="gainReductionBar" style="height: 100%; width: 0%; background: linear-gradient(to right, #00cc33, #ffcc00, #ff3300); transition: width 0.05s linear;"></div>
                        <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; font-size: 9px; color: #fff; font-weight: bold; text-shadow: 0 0 2px #000;">
                            <span id="gainReductionValue">0.0 dB</span>
                        </div>
                    </div>
                </div>
                <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #444;">
                    <div style="margin-bottom: 8px; font-size: 11px; color: #ccc;">Master Volume Meter</div>
                    <div id="masterVolumeMeter" style="width: 100%; height: 20px; background: #1a1a1a; border: 1px solid #444; border-radius: 3px; position: relative; overflow: hidden;">
                        <div id="masterVolumeBar" style="height: 100%; width: 0%; transition: width 0.05s linear;"></div>
                        <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; font-size: 9px; color: #fff; font-weight: bold; text-shadow: 0 0 2px #000;">
                            <span id="masterVolumeValue">-∞ dB</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="tab-view" class="tab-pane">
                <div class="control-group">
                    <label style="margin-bottom: 8px; display: block; font-weight: bold;">Presets:</label>
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="radio" name="presetMode" value="listener" id="presetListener" checked style="margin-right: 8px;">
                            <span>Listener</span>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="radio" name="presetMode" value="designer" id="presetDesigner" style="margin-right: 8px;">
                            <span>Designer</span>
                        </label>
                    </div>
                </div>
                <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #444;">
                    <div class="control-group toggle">
                        <input type="checkbox" id="showSources">
                        <label for="showSources">Show Sources</label>
                    </div>
                    <div class="control-group toggle">
                        <input type="checkbox" id="showSourceLabels">
                        <label for="showSourceLabels">Show Source Labels</label>
                    </div>
                    <div class="control-group toggle">
                        <input type="checkbox" id="showSourceRanges">
                        <label for="showSourceRanges">Show Source Range Circles</label>
                    </div>
                    <div class="control-group toggle">
                        <input type="checkbox" id="lockSourcePositions" checked>
                        <label for="lockSourcePositions">Lock Source Positions</label>
                    </div>
                    <div class="control-group toggle">
                        <input type="checkbox" id="snapToRings" checked>
                        <label for="snapToRings">Snap to Rings</label>
                    </div>
                </div>
            </div>
            
            <div id="tab-rings" class="tab-pane">
                <div class="control-group">
                    <label>Ring Radii (comma-separated):</label>
                    <input type="text" id="ringRadiiInput" value="40,70,100,130,160,190,220">
                    <button id="applyRingsBtn" style="margin-top: 5px; width: 100%;">Apply Rings</button>
                </div>
            </div>
            
            <div id="tab-debug" class="tab-pane">
                <div class="control-group toggle">
                    <input type="checkbox" id="debugVisuals">
                    <label for="debugVisuals">Debug Visuals (Canvas)</label>
                </div>
                <div class="control-group toggle">
                    <input type="checkbox" id="debugOverlay">
                    <label for="debugOverlay">Debug Overlay (Info Panel)</label>
                </div>
                <h3 style="margin-top: 15px; margin-bottom: 10px; font-size: 13px; color: #ccc;">Background Image</h3>
                <div class="control-group">
                    <label>Current Image:</label>
                    <input type="text" id="bgImageUrl" value="ses_cetveli_v3.jpg" style="margin-bottom: 5px;">
                    <div style="display: flex; gap: 5px; margin-bottom: 5px;">
                        <button id="reloadBgBtn" style="flex: 1;">Reload Background</button>
                    </div>
                    <div id="bgStatus" style="font-size: 11px; padding: 5px; background: #1a1a1a; border: 1px solid #444; border-radius: 3px; min-height: 20px;">
                        <span style="color: #888;">Status: </span><span id="bgStatusText">LOADING...</span>
                    </div>
                    <div id="bgDebug" style="font-size: 10px; padding: 3px; margin-top: 5px; color: #888; font-family: monospace;">
                        Attempting to load: <span id="bgDebugSrc">-</span>
                    </div>
                    <div id="fileProtocolWarning" style="display: none; font-size: 10px; padding: 5px; margin-top: 5px; background: #3a2a1a; border: 1px solid #664400; border-radius: 3px; color: #ffaa00;">
                        ⚠ You are running via file://. Use a local server (http://) for reliable asset loading.
                    </div>
                </div>
                <div class="control-group">
                    <label>Load Background Image:</label>
                    <input type="file" id="bgImageFile" accept="image/*" style="margin-top: 4px;">
                    <div style="font-size: 10px; color: #888; margin-top: 4px;">
                        Select a local image file to use as background
                    </div>
                </div>
                <div class="control-group">
                    <label>Live Readout</label>
                    <div id="readout" class="readout">Waiting for audio to start...</div>
                </div>
                <h3 style="margin-top: 15px; margin-bottom: 10px; font-size: 13px; color: #ccc;">Position Tracking</h3>
                <div class="control-group">
                    <label>Tracking Mode:</label>
                    <select id="trackingMode" style="width: 100%; margin-top: 4px; padding: 4px;">
                        <option value="manual">Manual (Drag)</option>
                        <option value="devicemotion">Device Motion (Test)</option>
                        <option value="arkit" disabled>ARKit (Native App Only)</option>
                    </select>
                    <div style="font-size: 10px; color: #888; margin-top: 4px;">
                        Note: ARKit requires native iOS app. See ARKIT_INTEGRATION.md
                    </div>
                </div>
                <div class="control-group toggle">
                    <input type="checkbox" id="enableTracking">
                    <label for="enableTracking">Enable Motion Tracking</label>
                </div>
                <div class="control-group">
                    <label>Tracking Status:</label>
                    <div id="trackingStatus" style="font-size: 11px; padding: 5px; background: #1a1a1a; border: 1px solid #444; border-radius: 3px; margin-top: 4px;">
                        <span style="color: #888;">Status: </span><span id="trackingStatusText">Disabled</span>
                    </div>
                </div>
            </div>
        </div>
        </div>
    </div>
    
    <script>
        // Helper functions
        function dbToLin(db) {
            return Math.pow(10, db / 20);
        }
        
        function linToDb(lin) {
            return 20 * Math.log10(Math.max(lin, 0.00001));
        }
        
        function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }
        
        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }
        
        // Get heatmap color from gradient (t: 0 = newest/yellow, 1 = oldest/purple)
        function getHeatmapColor(t) {
            t = clamp(t, 0, 1);
            
            // Color stops for gradient: yellow -> lime green -> turquoise -> blue -> indigo -> purple
            const colors = [
                { r: 255, g: 255, b: 0 },      // 0.0: Bright yellow (newest)
                { r: 204, g: 255, b: 0 },      // 0.2: Lime green
                { r: 0, g: 255, b: 200 },      // 0.4: Turquoise
                { r: 0, g: 191, b: 255 },      // 0.6: Sky blue
                { r: 75, g: 0, b: 200 },       // 0.8: Indigo
                { r: 128, g: 0, b: 128 }       // 1.0: Purple (oldest)
            ];
            
            const stops = [0, 0.2, 0.4, 0.6, 0.8, 1.0];
            
            // Find the two colors to interpolate between
            let i = 0;
            for (let j = 0; j < stops.length - 1; j++) {
                if (t >= stops[j] && t <= stops[j + 1]) {
                    i = j;
                    break;
                }
            }
            
            // Interpolate between colors[i] and colors[i+1]
            const tLocal = (t - stops[i]) / (stops[i + 1] - stops[i]);
            const c1 = colors[i];
            const c2 = colors[i + 1];
            
            return {
                r: Math.round(c1.r + (c2.r - c1.r) * tLocal),
                g: Math.round(c1.g + (c2.g - c1.g) * tLocal),
                b: Math.round(c1.b + (c2.b - c1.b) * tLocal)
            };
        }
        
        // Default background image source (canonical)
        const DEFAULT_BG_SRC = 'ses_cetveli_v3.jpg';
        
        // Protocol detection
        const isFileProtocol = (window.location.protocol === 'file:');
        
        // State
        const state = {
            audioCtx: null,
            masterGain: null,
            masterAnalyser: null,
            listener: { x: 234.1, y: 234.8 },
            sources: [],
            ringRadii: [40, 70, 100, 130, 160, 190, 220],
            ringCenter: { x: 240, y: 240 },
            snapToRings: true, // Default: ON (Listener Mode preset)
            debugVisuals: false, // Default: hidden
            debugOverlayVisible: false, // Default: hidden
            showSources: false, // Default: OFF (Listener Mode preset)
            showSourceLabels: false, // Default: hide labels
            showSourceRanges: false, // Default: OFF (Listener Mode preset)
            lockSourcePositions: true, // Default: locked
            currentPreset: 'listener', // Current preset mode
            panningEnabled: true,
            panDistance: 120,
            nearestN: 4,
            globalRmax: 80,
            falloffPower: 2.2,
            masterVolume: -60, // Start at -60 dB, fade to 0 dB on start
            compressorEnabled: true, // Compressor on/off state
            isPlaying: false,
            autoStartAttempted: false, // Track if auto-start has been attempted
            dragging: null,
            dragType: null, // 'listener' or source index
            dragStartRadius: null, // Radius from ring center when drag started (for snap to rings)
            worldSize: 240,
            canvasPixelSize: 240,
            scale: 1,
            bgImage: {
                image: null,
                status: 'LOADING', // LOADING, LOADED, ERROR
                src: DEFAULT_BG_SRC,
                errorMessage: null,
                naturalWidth: 0,
                naturalHeight: 0,
            },
            framesDrawn: 0,
            visualPower: 1.8, // Visual falloff power for alpha
            visualTau: 0.18, // Visual alpha smoothing time constant (seconds)
            lastFrameTime: performance.now(),
            lastTXMuteUpdate: performance.now() / 1000, // Last update time for T/X mute multiplier
            loadingProgress: {
                isLoading: false,
                progress: 0, // 0 to 1
                totalSources: 0,
                loadedSources: 0,
                showListenButton: false, // Show "Listen!" button after loading completes
                overlayOpacity: 0.7, // Overlay opacity (fades out when listen button is clicked)
                buttonOpacity: 0 // Button opacity (fades in when shown, fades out when clicked)
            },
            // ARKit/DeviceMotion tracking state
            tracking: {
                enabled: false,
                mode: 'manual', // 'manual', 'devicemotion', 'arkit' (arkit only in native app)
                lastPosition: { x: 234.1, y: 234.8 },
                velocity: { x: 0, y: 0 },
                lastUpdateTime: null,
                smoothingAlpha: 0.4, // Exponential smoothing factor (0-1, lower = smoother)
                maxSpeed: 2.0, // Maximum speed in canvas units per second (for outlier detection)
                qrAnchorScanned: false,
                qrAnchorPosition: null, // QR anchor position in world coordinates
            },
        };
        
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas ? canvas.getContext('2d', { 
            alpha: true,
            desynchronized: false,
            willReadFrequently: false
        }) : null;
        const canvasContainer = document.getElementById('canvas-container');
        const controlPanel = document.getElementById('control-panel');
        
        // Enable high-quality rendering for canvas
        if (ctx) {
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            if (ctx.textRenderingOptimization) {
                ctx.textRenderingOptimization = 'optimizeQuality';
            }
        }
        
        // Safety check
        if (!canvas || !ctx) {
            console.error('Canvas or context not available');
        }
        
        // Check for file:// protocol and show warning
        if (isFileProtocol) {
            const warning = document.getElementById('fileProtocolWarning');
            if (warning) {
                warning.style.display = 'block';
            }
            // Make URL input read-only in file:// mode (it's just for display)
            const urlInput = document.getElementById('bgImageUrl');
            if (urlInput) {
                urlInput.readOnly = true;
                urlInput.title = 'In file:// mode, use the file picker below to select an image';
            }
        }
        
        // Background image management - ONE canonical image object
        function initBgImage() {
            // Create the ONE canonical image object
            const img = new Image();
            img.crossOrigin = 'anonymous'; // Allow CORS if needed
            
            // Set up handlers on the canonical image object
            img.onload = () => {
                state.bgImage.status = 'LOADED';
                state.bgImage.naturalWidth = img.naturalWidth;
                state.bgImage.naturalHeight = img.naturalHeight;
                state.bgImage.errorMessage = null;
                // Update URL input if it doesn't match current src
                const urlInput = document.getElementById('bgImageUrl');
                if (urlInput && urlInput.value !== state.bgImage.src) {
                    // Only update if src is a filename (from file input), not a full URL or data URL
                    if (state.bgImage.src && !state.bgImage.src.includes('://') && !state.bgImage.src.startsWith('data:')) {
                        urlInput.value = state.bgImage.src;
                    }
                }
                updateBgStatus();
                console.log('Background image loaded:', state.bgImage.src, `${img.naturalWidth}x${img.naturalHeight}`);
                // Force immediate redraw when background loads
                draw();
            };
            
            img.onerror = (e) => {
                state.bgImage.status = 'ERROR';
                // Extract meaningful error info
                const srcDisplay = state.bgImage.src || img.src || 'unknown';
                state.bgImage.errorMessage = `Failed to load: ${srcDisplay}`;
                state.bgImage.naturalWidth = 0;
                state.bgImage.naturalHeight = 0;
                updateBgStatus();
                console.error('Background image error:', srcDisplay, e);
                draw(); // Redraw to show placeholder
            };
            
            // Store the canonical image object in state
            state.bgImage.image = img;
            return img;
        }
        
        function loadBgImage(src, useCacheBust = false) {
            // Use the SAME canonical image object
            const img = state.bgImage.image;
            if (!img) {
                console.warn('Background image object not initialized, cannot load:', src);
                state.bgImage.status = 'ERROR';
                state.bgImage.errorMessage = 'Image object not initialized';
                updateBgStatus();
                return;
            }
            
            state.bgImage.status = 'LOADING';
            state.bgImage.errorMessage = null;
            
            // Update debug display
            const debugSrc = document.getElementById('bgDebugSrc');
            if (debugSrc) {
                debugSrc.textContent = src;
            }
            
            updateBgStatus();
            
            let finalSrc = src;
            if (useCacheBust) {
                const separator = src.includes('?') ? '&' : '?';
                finalSrc = src + separator + 'v=' + Date.now();
            }
            
            // Set src on the SAME canonical image object
            try {
                img.src = finalSrc;
                state.bgImage.src = src; // Store original src (without cache-bust)
                
                // If image is already cached/loaded, onload might not fire
                // Check after a microtask to ensure onload fires
                setTimeout(() => {
                    if (img.complete && img.naturalWidth > 0 && state.bgImage.status === 'LOADING') {
                        // Image already loaded from cache, trigger onload manually
                        img.onload();
                    }
                }, 0);
            } catch (err) {
                console.error('Error setting image src:', err);
                state.bgImage.status = 'ERROR';
                state.bgImage.errorMessage = `Failed to set src: ${src}`;
                updateBgStatus();
            }
        }
        
        function updateBgStatus() {
            const statusText = document.getElementById('bgStatusText');
            const status = state.bgImage.status;
            const src = state.bgImage.src || 'none';
            
            if (status === 'LOADING') {
                statusText.textContent = `LOADING... (${src})`;
                statusText.style.color = '#ffaa00';
            } else if (status === 'LOADED') {
                const dims = `${state.bgImage.naturalWidth} × ${state.bgImage.naturalHeight}`;
                statusText.textContent = `LOADED (${dims}) - ${src}`;
                statusText.style.color = '#00cc33';
            } else if (status === 'ERROR') {
                statusText.textContent = `ERROR: ${state.bgImage.errorMessage || 'Unknown error'} - ${src}`;
                statusText.style.color = '#cc3300';
            }
        }
        
        // Update canvas size and scale
        function updateCanvasSize() {
            if (!canvas || !canvasContainer) {
                console.warn('Canvas elements not available for sizing');
                return;
            }
            
            // Get available space (account for right panel)
            const panel = document.getElementById('control-panel');
            let panelWidth = 360; // Default width
            if (panel) {
                if (panel.classList.contains('collapsed')) {
                    panelWidth = 40;
                } else {
                    panelWidth = panel.offsetWidth || 360;
                }
            }
            
            const availableHeight = window.innerHeight || 600;
            const availableWidth = (window.innerWidth || 800) - panelWidth;
            
            // If panel width is invalid during init, schedule a retry
            if (panelWidth <= 0 && state.canvasPixelSize === 240) {
                // Schedule retry on next frame
                requestAnimationFrame(() => {
                    updateCanvasSize();
                });
                return;
            }
            
            // Calculate largest square that fits
            const canvasPixelSize = Math.max(100, Math.min(availableWidth, availableHeight));
            state.canvasPixelSize = canvasPixelSize;
            
            // Set canvas element size
            canvas.width = canvasPixelSize;
            canvas.height = canvasPixelSize;
            canvas.style.width = canvasPixelSize + 'px';
            canvas.style.height = canvasPixelSize + 'px';
            
            // Calculate scale: world units (0..240) to canvas pixels
            state.scale = canvasPixelSize / state.worldSize;
            
            // Ensure scale is valid
            if (state.scale <= 0 || !isFinite(state.scale)) {
                state.scale = 1;
            }
            
            // Center the canvas container
            canvasContainer.style.width = canvasPixelSize + 'px';
            canvasContainer.style.height = canvasPixelSize + 'px';
        }
        
        // Convert screen coordinates to world coordinates (0..240)
        function screenToWorld(screenX, screenY) {
            const rect = canvas.getBoundingClientRect();
            const localX = screenX - rect.left;
            const localY = screenY - rect.top;
            return {
                x: localX / state.scale,
                y: localY / state.scale
            };
        }
        
        // Initialize default sources
        function initDefaultSources() {
            // 21 sources: A1-A7, B1-B6, C1-C4, D1-D4
            const sourceNames = ['A1', 'A2', 'A3', 'A4', 'A5', 'A6', 'A7', 'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'C1', 'C2', 'C3', 'C4', 'D1', 'D2', 'D3', 'D4'];
            
            // A group: A1 (194, 206) to A7 (30, 95) - 7 sources, 6 intervals
            const a1 = { x: 194, y: 206 };
            const a7 = { x: 30, y: 95 };
            const aPositions = [];
            for (let i = 0; i < 7; i++) {
                aPositions.push({
                    x: a1.x + (i / 6) * (a7.x - a1.x),
                    y: a1.y + (i / 6) * (a7.y - a1.y)
                });
            }
            
            // B group: B1 (180, 159) to B6 (75, 18) - 6 sources, 5 intervals
            const b1 = { x: 180, y: 159 };
            const b6 = { x: 75, y: 18 };
            const bPositions = [];
            for (let i = 0; i < 6; i++) {
                bPositions.push({
                    x: b1.x + (i / 5) * (b6.x - b1.x),
                    y: b1.y + (i / 5) * (b6.y - b1.y)
                });
            }
            
            // C group: C1 (116, 221) to C4 (22, 172) - symmetric distribution
            const c1 = { x: 116, y: 221 };
            const c4 = { x: 22, y: 172 };
            // Linear interpolation for C2 and C3
            const c2 = {
                x: c1.x + (c4.x - c1.x) / 3,
                y: c1.y + (c4.y - c1.y) / 3
            };
            const c3 = {
                x: c1.x + 2 * (c4.x - c1.x) / 3,
                y: c1.y + 2 * (c4.y - c1.y) / 3
            };
            
            // D group: D1 (221, 116) to D4 (172, 22) - symmetric distribution
            const d1 = { x: 221, y: 116 };
            const d4 = { x: 172, y: 22 };
            // Linear interpolation for D2 and D3
            const d2 = {
                x: d1.x + (d4.x - d1.x) / 3,
                y: d1.y + (d4.y - d1.y) / 3
            };
            const d3 = {
                x: d1.x + 2 * (d4.x - d1.x) / 3,
                y: d1.y + 2 * (d4.y - d1.y) / 3
            };
            
            const defaultPositions = [...aPositions, ...bPositions, c1, c2, c3, c4, d1, d2, d3, d4];
            
            // Special rmax values for specific sources
            const specialRmax = {
                'B1': 40,
                'B5': 45,
                'B6': 80,
                'C2': 110,
                'C3': 90,
                'D2': 110,
                'D3': 90
            };
            
            for (let i = 0; i < 21; i++) {
                const pos = defaultPositions[i];
                const sourceId = sourceNames[i];
                state.sources.push({
                    id: sourceId,
                    x: pos.x,
                    y: pos.y,
                    audioBuffer: null,
                    sourceNode: null,
                    gainNode: null,
                    pannerNode: null,
                    rmax: specialRmax[sourceId] || state.globalRmax,
                    falloffPower: state.falloffPower,
                    gainSmoothness: 0.05, // Gain fade smoothness (time constant in seconds)
                    muted: false,
                    solo: false,
                    visualAlpha: 0, // Current visual alpha (smoothed)
                });
            }
            updateSourcesList();
            updateMixerList();
            
            // Initialize T1 - moving source
            initT1Source();
            
            // Initialize X1 - moving source on routes
            initX1Source();
        }
        
        // Initialize T1 moving source
        function initT1Source() {
            // Find T1 source or create it
            let t1Source = state.sources.find(s => s.id === 'T1');
            if (!t1Source) {
                t1Source = {
                    id: 'T1',
                    x: state.ringCenter.x,
                    y: state.ringCenter.y,
                    audioBuffer: null,
                    sourceNode: null,
                    gainNode: null,
                    pannerNode: null,
                    rmax: state.globalRmax,
                    falloffPower: state.falloffPower,
                    gainSmoothness: 1.00, // Gain fade smoothness (time constant in seconds)
                    muted: false,
                    solo: false,
                    visualAlpha: 0,
                    // Movement properties
                    isMoving: false,
                    currentRingRadius: null,
                    startAngle: null,
                    endAngle: null,
                    movementDuration: null,
                    movementStartTime: null,
                    movementDirection: null, // 1 for clockwise, -1 for counterclockwise
                };
                state.sources.push(t1Source);
                updateSourcesList();
                updateMixerList();
            }
            
            // Start T1 movement
            startT1Movement(t1Source);
        }
        
        // Load random audio file for T1 or X1
        async function loadRandomAudioForSource(source, sourcePrefix) {
            if (!state.audioCtx) {
                try {
                    initAudio();
                } catch (err) {
                    console.warn(`[Random Audio] Failed to init audio context for ${sourcePrefix}:`, err);
                    return null;
                }
            }
            
            if (!state.audioCtx) {
                console.warn(`[Random Audio] Audio context not available for ${sourcePrefix}`);
                return null;
            }
            
            // Determine file prefix: T1 -> T, X1 -> X
            const filePrefix = sourcePrefix.charAt(0); // 'T' or 'X'
            
            // Fixed number of files to check (to avoid 404 errors)
            // T1: T1-T4, X1: X1-X5
            const maxFiles = (filePrefix === 'T') ? 4 : 5;
            
            // Try to find available audio files (T1.mp3, T2.mp3, T3.mp3, etc. or X1.mp3, X2.mp3, X3.mp3, etc.)
            const extensions = ['.mp3', '.wav', '.ogg', '.m4a', '.aac', '.webm'];
            
            // First, find all available files
            const availableFiles = [];
            for (let i = 1; i <= maxFiles; i++) {
                for (const ext of extensions) {
                    const filename = `${filePrefix}${i}${ext}`; // T1.mp3, T2.mp3, etc. or X1.mp3, X2.mp3, etc.
                    
                    try {
                        // Use HEAD request first to check if file exists (lighter than GET)
                        const response = await fetch(filename, { method: 'HEAD' });
                        if (response.ok) {
                            availableFiles.push(filename);
                            break; // Found one, move to next number
                        }
                    } catch (e) {
                        // Not found, continue silently (don't log 404 errors)
                    }
                }
            }
            
            if (availableFiles.length === 0) {
                console.log(`[Random Audio] No audio files found for ${sourcePrefix} (searched ${filePrefix}1-${filePrefix}${maxFiles})`);
                return null;
            }
            
            // Select random file
            const selectedFile = availableFiles[Math.floor(Math.random() * availableFiles.length)];
            
            try {
                const response = await fetch(selectedFile);
                if (response.ok) {
                    const arrayBuffer = await response.arrayBuffer();
                    const audioBuffer = await state.audioCtx.decodeAudioData(arrayBuffer);
                    console.log(`[Random Audio] ✓ Loaded ${sourcePrefix}: ${selectedFile}`);
                    return audioBuffer;
                }
            } catch (err) {
                console.warn(`[Random Audio] Failed to load ${selectedFile}:`, err);
                return null;
            }
            
            return null;
        }
        
        // Start T1 movement on a random ring
        function startT1Movement(t1Source) {
            // Select random ring from 130, 160, 190
            const availableRings = [130, 160, 190];
            const selectedRing = availableRings[Math.floor(Math.random() * availableRings.length)];
            
            // Find a valid starting angle (not in restricted bottom-right quadrant)
            let startAngle;
            let attempts = 0;
            const centerX = state.worldSize / 2;
            const centerY = state.worldSize / 2;
            do {
                startAngle = Math.random() * Math.PI * 2;
                const testX = state.ringCenter.x + Math.cos(startAngle) * selectedRing;
                const testY = state.ringCenter.y + Math.sin(startAngle) * selectedRing;
                if (!isInRestrictedArea(testX, testY) && 
                    !isTooCloseToB6(testX, testY) && 
                    !isOutsideMaxRing(testX, testY)) {
                    break;
                }
                attempts++;
            } while (attempts < 50); // Safety limit
            
            // Movement direction (clockwise or counterclockwise)
            let direction = Math.random() < 0.5 ? 1 : -1;
            
            // End angle: move approximately 180 degrees (half circle) in the chosen direction
            let endAngle = startAngle + direction * Math.PI;
            
            // Ensure end position is also not in restricted area, too close to B6, or outside max ring
            let endX = state.ringCenter.x + Math.cos(endAngle) * selectedRing;
            let endY = state.ringCenter.y + Math.sin(endAngle) * selectedRing;
            if (isInRestrictedArea(endX, endY) || isTooCloseToB6(endX, endY) || isOutsideMaxRing(endX, endY)) {
                // Reverse direction if end would be invalid
                direction = -direction;
                endAngle = startAngle + direction * Math.PI;
                endX = state.ringCenter.x + Math.cos(endAngle) * selectedRing;
                endY = state.ringCenter.y + Math.sin(endAngle) * selectedRing;
                // If still invalid, try different angle
                if (isInRestrictedArea(endX, endY) || isTooCloseToB6(endX, endY) || isOutsideMaxRing(endX, endY)) {
                    // Use a smaller movement range
                    endAngle = startAngle + direction * Math.PI * 0.8; // 80% of half circle instead of 100%
                }
            }
            
            // Random movement duration between 10-15 seconds (faster appearance, 2x more frequent)
            const duration = 10 + Math.random() * 5; // 10 to 15 seconds
            
            // Set movement properties
            t1Source.isMoving = true;
            t1Source.currentRingRadius = selectedRing;
            t1Source.startAngle = startAngle;
            t1Source.endAngle = endAngle;
            t1Source.movementDuration = duration;
            t1Source.movementStartTime = performance.now() / 1000; // Convert to seconds
            t1Source.movementDirection = direction;
            
            // Set initial position
            t1Source.x = state.ringCenter.x + Math.cos(startAngle) * selectedRing;
            t1Source.y = state.ringCenter.y + Math.sin(startAngle) * selectedRing;
            
            // Load random audio file and start from random position (async, fire and forget)
            loadAndStartRandomAudio(t1Source, 'T1');
        }
        
        // Load and start random audio for T1 or X1
        async function loadAndStartRandomAudio(source, sourcePrefix) {
            if (!state.audioCtx || !state.isPlaying) return;
            
            const randomAudioBuffer = await loadRandomAudioForSource(source, sourcePrefix);
            if (randomAudioBuffer) {
                // Stop current audio if playing
                if (source.sourceNode) {
                    try {
                        source.sourceNode.stop();
                    } catch (e) {
                        // Already stopped
                    }
                    source.sourceNode = null;
                }
                
                // Create new source node
                const sourceNode = state.audioCtx.createBufferSource();
                sourceNode.buffer = randomAudioBuffer;
                sourceNode.loop = true;
                
                const gainNode = state.audioCtx.createGain();
                const pannerNode = state.audioCtx.createStereoPanner();
                
                sourceNode.connect(gainNode);
                gainNode.connect(pannerNode);
                pannerNode.connect(state.masterGain);
                
                source.audioBuffer = randomAudioBuffer;
                source.sourceNode = sourceNode;
                source.gainNode = gainNode;
                source.pannerNode = pannerNode;
                
                gainNode.gain.value = 0;
                pannerNode.pan.value = 0;
                
                // Start from random position (0 to duration - 1 second, minimum 0)
                const duration = randomAudioBuffer.duration;
                const maxOffset = Math.max(0, duration - 1);
                const randomOffset = Math.random() * maxOffset;
                
                sourceNode.start(0, randomOffset);
            }
        }
        
        // Update T1 position during movement
        function updateT1Movement(t1Source) {
            if (!t1Source.isMoving) {
                return;
            }
            
            const currentTime = performance.now() / 1000; // Current time in seconds
            const elapsed = currentTime - t1Source.movementStartTime;
            
            if (elapsed >= t1Source.movementDuration) {
                // Movement completed, start new movement
                startT1Movement(t1Source);
                return;
            }
            
            // Calculate progress (0 to 1)
            const progress = elapsed / t1Source.movementDuration;
            
            // Use smooth easing (ease-in-out)
            const easedProgress = progress < 0.5 
                ? 2 * progress * progress 
                : 1 - Math.pow(-2 * progress + 2, 2) / 2;
            
            // Interpolate angle
            let currentAngle = t1Source.startAngle + (t1Source.endAngle - t1Source.startAngle) * easedProgress;
            
            // Calculate position
            let newX = state.ringCenter.x + Math.cos(currentAngle) * t1Source.currentRingRadius;
            let newY = state.ringCenter.y + Math.sin(currentAngle) * t1Source.currentRingRadius;
            
            // Clamp position if it would enter restricted area, get too close to B6, or go outside max ring
            if (isInRestrictedArea(newX, newY) || isTooCloseToB6(newX, newY) || isOutsideMaxRing(newX, newY)) {
                // If position is invalid, use previous position
                return;
            }
            
            // Update position on the ring
            t1Source.x = newX;
            t1Source.y = newY;
        }
        
        // Check if position is in the restricted area (bottom-right quadrant)
        function isInRestrictedArea(x, y) {
            const centerX = state.worldSize / 2; // 120
            const centerY = state.worldSize / 2; // 120
            // Bottom-right quadrant: x > centerX && y > centerY
            return x > centerX && y > centerY;
        }
        
        // Check if position is too close to B6
        function isTooCloseToB6(x, y, minDistance = 40) {
            // B6 position is (75, 18) - hardcoded to avoid dependency on state.sources timing
            const b6X = 75;
            const b6Y = 18;
            const dist = distance(x, y, b6X, b6Y);
            return dist < minDistance;
        }
        
        // Check if position is outside 220 radius ring
        function isOutsideMaxRing(x, y, maxRadius = 220) {
            const dx = x - state.ringCenter.x;
            const dy = y - state.ringCenter.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            return dist > maxRadius;
        }
        
        // Define routes for X1 movement
        function getX1Routes() {
            const allRoutes = [
                // C1 to C4 and back
                { start: { x: 116, y: 221 }, end: { x: 22, y: 172 }, name: 'C1-C4' },
                { start: { x: 22, y: 172 }, end: { x: 116, y: 221 }, name: 'C4-C1' },
                // A1 to A7 and back
                { start: { x: 194, y: 206 }, end: { x: 30, y: 95 }, name: 'A1-A7' },
                { start: { x: 30, y: 95 }, end: { x: 194, y: 206 }, name: 'A7-A1' },
                // B1 to B6 and back (filtered - B6 too close)
                { start: { x: 180, y: 159 }, end: { x: 75, y: 18 }, name: 'B1-B6' },
                { start: { x: 75, y: 18 }, end: { x: 180, y: 159 }, name: 'B6-B1' },
                // D1 to D4 and back
                { start: { x: 221, y: 116 }, end: { x: 172, y: 22 }, name: 'D1-D4' },
                { start: { x: 172, y: 22 }, end: { x: 221, y: 116 }, name: 'D4-D1' }
            ];
            
            // Return all routes - filtering will be done during movement (clamping)
            // This ensures X1 can always appear, and movement restrictions are enforced during update
            return allRoutes;
        }
        
        // Initialize X1 moving source
        function initX1Source() {
            // Find X1 source or create it
            let x1Source = state.sources.find(s => s.id === 'X1');
            if (!x1Source) {
                x1Source = {
                    id: 'X1',
                    x: state.ringCenter.x,
                    y: state.ringCenter.y,
                    audioBuffer: null,
                    sourceNode: null,
                    gainNode: null,
                    pannerNode: null,
                    rmax: state.globalRmax,
                    falloffPower: state.falloffPower,
                    gainSmoothness: 1.00, // Gain fade smoothness (time constant in seconds)
                    muted: false,
                    solo: false,
                    visualAlpha: 0,
                    // Movement properties
                    isMoving: false,
                    isVisible: false, // For fade in/out
                    currentRoute: null,
                    startProgress: null, // Start position on route (0-1)
                    endProgress: null, // End position on route (0-1)
                    movementDuration: null,
                    movementStartTime: null,
                    fadeInDuration: 0.5, // 0.5 seconds fade in
                    fadeOutDuration: 0.5, // 0.5 seconds fade out
                    fadeStartTime: null,
                    fadeType: null, // 'in' or 'out'
                    fadeMultiplier: 0, // 0 to 1, for audio and visual fade
                };
                state.sources.push(x1Source);
                updateSourcesList();
                updateMixerList();
            }
            
            // Start X1 movement
            startX1Movement(x1Source);
        }
        
        // Start X1 movement on a random route
        function startX1Movement(x1Source) {
            const routes = getX1Routes();
            
            // Safety check: if no routes available, return early
            if (!routes || routes.length === 0) {
                console.warn('[X1] No valid routes available, skipping movement');
                return;
            }
            
            const selectedRoute = routes[Math.floor(Math.random() * routes.length)];
            
            // Safety check: if selectedRoute is undefined or invalid, return early
            if (!selectedRoute || !selectedRoute.start || !selectedRoute.end) {
                console.warn('[X1] Selected route is invalid, skipping movement', selectedRoute);
                return;
            }
            
            // Find valid progress range that avoids restricted area
            // Use simple random range - restrictions will be enforced during movement (clamping)
            let startProgress, endProgress;
            let attempts = 0;
            let foundValid = false;
            
            // Try to find a valid range, but don't be too strict
            do {
                startProgress = Math.random(); // 0 to 1
                const routeLength = 0.3 + Math.random() * 0.5; // 30% to 80% of route
                endProgress = startProgress + routeLength;
                if (endProgress > 1) {
                    endProgress = 1;
                }
                
                // Check if start and end positions are valid (only check restricted area - most important)
                const startX = selectedRoute.start.x + (selectedRoute.end.x - selectedRoute.start.x) * startProgress;
                const startY = selectedRoute.start.y + (selectedRoute.end.y - selectedRoute.start.y) * startProgress;
                const endX = selectedRoute.start.x + (selectedRoute.end.x - selectedRoute.start.x) * endProgress;
                const endY = selectedRoute.start.y + (selectedRoute.end.y - selectedRoute.start.y) * endProgress;
                
                // Only check restricted area - B6 and max ring will be handled during movement
                const startValid = !isInRestrictedArea(startX, startY);
                const endValid = !isInRestrictedArea(endX, endY);
                
                if (startValid && endValid) {
                    foundValid = true;
                    break;
                }
                attempts++;
            } while (attempts < 50); // Reasonable attempts
            
            // If no valid range found, use simple random range (will be clamped during movement)
            if (!foundValid) {
                startProgress = Math.random() * 0.5; // Start in first half
                endProgress = 0.5 + Math.random() * 0.5; // End in second half
            }
            
            // Random movement duration between 6-10 seconds (similar to T1)
            const duration = 6 + Math.random() * 4; // 6 to 10 seconds
            
            // Set movement properties
            x1Source.isMoving = true;
            x1Source.currentRoute = selectedRoute;
            x1Source.startProgress = startProgress;
            x1Source.endProgress = endProgress;
            x1Source.movementDuration = duration;
            x1Source.movementStartTime = performance.now() / 1000; // Convert to seconds
            
            // Calculate initial position
            const initialX = selectedRoute.start.x + (selectedRoute.end.x - selectedRoute.start.x) * startProgress;
            const initialY = selectedRoute.start.y + (selectedRoute.end.y - selectedRoute.start.y) * startProgress;
            x1Source.x = initialX;
            x1Source.y = initialY;
            
            // Start fade in
            x1Source.isVisible = true;
            x1Source.fadeType = 'in';
            x1Source.fadeStartTime = performance.now() / 1000;
            
            // Load random audio file and start from random position (async, fire and forget)
            loadAndStartRandomAudio(x1Source, 'X1');
        }
        
        // Update X1 position during movement
        function updateX1Movement(x1Source) {
            if (!x1Source.isMoving || !x1Source.currentRoute) {
                return;
            }
            
            const currentTime = performance.now() / 1000; // Current time in seconds
            const elapsed = currentTime - x1Source.movementStartTime;
            
            // Handle fade in
            if (x1Source.fadeType === 'in' && x1Source.fadeStartTime !== null) {
                const fadeElapsed = currentTime - x1Source.fadeStartTime;
                if (fadeElapsed >= x1Source.fadeInDuration) {
                    x1Source.fadeType = null;
                    x1Source.fadeStartTime = null;
                }
            }
            
            // Check if movement is complete
            if (elapsed >= x1Source.movementDuration) {
                // Start fade out if not already started
                if (x1Source.fadeType !== 'out') {
                    x1Source.fadeType = 'out';
                    x1Source.fadeStartTime = currentTime;
                }
            }
            
            // Handle fade out (if movement is ending)
            if (x1Source.fadeType === 'out' && x1Source.fadeStartTime !== null) {
                const fadeElapsed = currentTime - x1Source.fadeStartTime;
                if (fadeElapsed >= x1Source.fadeOutDuration) {
                    // Fade out complete, start new movement
                    x1Source.isVisible = false;
                    x1Source.fadeType = null;
                    x1Source.fadeStartTime = null;
                    startX1Movement(x1Source);
                    return;
                }
                // During fade out, don't update position (movement is complete)
                return;
            }
            
            // Calculate progress (0 to 1)
            const progress = Math.min(elapsed / x1Source.movementDuration, 1);
            
            // Use smooth easing (ease-in-out)
            const easedProgress = progress < 0.5 
                ? 2 * progress * progress 
                : 1 - Math.pow(-2 * progress + 2, 2) / 2;
            
            // Interpolate position on route
            const routeProgress = x1Source.startProgress + (x1Source.endProgress - x1Source.startProgress) * easedProgress;
            let newX = x1Source.currentRoute.start.x + (x1Source.currentRoute.end.x - x1Source.currentRoute.start.x) * routeProgress;
            let newY = x1Source.currentRoute.start.y + (x1Source.currentRoute.end.y - x1Source.currentRoute.start.y) * routeProgress;
            
            // Clamp position if it would enter restricted area, get too close to B6, or go outside max ring
            if (isInRestrictedArea(newX, newY) || isTooCloseToB6(newX, newY) || isOutsideMaxRing(newX, newY)) {
                // If position is invalid, use previous position
                return;
            }
            
            x1Source.x = newX;
            x1Source.y = newY;
        }
        
        // Update X1 fade (for audio and visual)
        function updateX1Fade(x1Source) {
            if (!x1Source.isVisible) {
                // Not visible - set fade to 0
                x1Source.fadeMultiplier = 0;
                return;
            }
            
            if (!x1Source.fadeStartTime || !x1Source.fadeType) {
                // No fade in progress - fully visible
                x1Source.fadeMultiplier = 1;
                return;
            }
            
            const currentTime = performance.now() / 1000;
            const fadeElapsed = currentTime - x1Source.fadeStartTime;
            
            if (x1Source.fadeType === 'in') {
                const fadeProgress = Math.min(fadeElapsed / x1Source.fadeInDuration, 1);
                x1Source.fadeMultiplier = fadeProgress; // 0 to 1
            } else if (x1Source.fadeType === 'out') {
                const fadeProgress = Math.min(fadeElapsed / x1Source.fadeOutDuration, 1);
                x1Source.fadeMultiplier = 1 - fadeProgress; // 1 to 0
            } else {
                x1Source.fadeMultiplier = 1;
            }
        }
        
        // Auto-load audio files matching source names
        async function autoLoadSourceAudio(source, index) {
            // Only try in http:// protocol (file:// won't work due to browser security)
            if (isFileProtocol) {
                // Silently skip - user should use "Load Audio Files" button in Sources tab
                return;
            }
            
            // Try different audio file extensions
            const extensions = ['.mp3', '.wav', '.ogg', '.m4a', '.aac', '.webm'];
            const sourceName = source.id;
            
            // Ensure audio context exists
            if (!state.audioCtx) {
                try {
                    initAudio();
                } catch (err) {
                    console.warn(`[Auto-load] Failed to init audio context for ${sourceName}:`, err);
                    return;
                }
            }
            
            if (!state.audioCtx) {
                console.warn(`[Auto-load] Audio context not available for ${sourceName}`);
                return;
            }
            
            // Try each extension
            for (const ext of extensions) {
                const filename = sourceName + ext;
                try {
                    const response = await fetch(filename);
                    if (response.ok) {
                        const arrayBuffer = await response.arrayBuffer();
                        const audioBuffer = await state.audioCtx.decodeAudioData(arrayBuffer);
                        state.sources[index].audioBuffer = audioBuffer;
                        console.log(`[Auto-load] ✓ Loaded ${sourceName}: ${filename}`);
                        updateSourcesList();
                        return; // Success, stop trying other extensions
                    } else {
                        // Log non-OK responses for debugging
                        if (ext === extensions[0]) { // Only log first attempt to avoid spam
                            console.log(`[Auto-load] ${sourceName}: ${filename} returned status ${response.status}`);
                        }
                    }
                } catch (err) {
                    // File not found or other error, try next extension
                    if (ext === extensions[extensions.length - 1]) {
                        // Only log on last extension to avoid spam
                        console.log(`[Auto-load] ${sourceName}: No audio file found (tried: ${extensions.join(', ')})`);
                    }
                    continue;
                }
            }
        }
        
        // Load audio files for all sources
        async function autoLoadAllSourceAudio() {
            // Only try in http:// protocol
            if (isFileProtocol) {
                console.log('[Auto-load] file:// protocol detected. Use "Load Audio Files" in Sources tab to load audio files.');
                return;
            }
            
            console.log('[Auto-load] Starting auto-load for all sources...');
            
            // Initialize loading state
            const sourcesToLoad = state.sources.filter(s => !s.audioBuffer).length;
            if (sourcesToLoad > 0) {
                state.loadingProgress.isLoading = true;
                state.loadingProgress.totalSources = sourcesToLoad;
                state.loadingProgress.loadedSources = 0;
                state.loadingProgress.progress = 0;
            }
            
            // Wait a bit for audio context to be ready
            await new Promise(resolve => setTimeout(resolve, 200));
            
            // Try to initialize audio context if not already done
            if (!state.audioCtx) {
                try {
                    initAudio();
                } catch (err) {
                    console.warn('[Auto-load] Could not initialize audio context:', err);
                }
            }
            
            let loadedCount = 0;
            for (let i = 0; i < state.sources.length; i++) {
                const source = state.sources[i];
                // Only load if not already loaded
                if (!source.audioBuffer) {
                    await autoLoadSourceAudio(source, i);
                    if (state.sources[i].audioBuffer) {
                        loadedCount++;
                    }
                    // Update loading progress
                    if (state.loadingProgress.isLoading) {
                        state.loadingProgress.loadedSources = loadedCount;
                        state.loadingProgress.progress = loadedCount / state.loadingProgress.totalSources;
                    }
                    // Small delay between requests to avoid overwhelming
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
            }
            
            // Mark loading as complete
            state.loadingProgress.progress = 1;
            
            // Force a redraw to show 100% loading bar
            draw();
            
            if (loadedCount > 0) {
                console.log(`[Auto-load] Successfully loaded ${loadedCount} audio files`);
                updateSourcesList();
                
                // Show "Listen!" button after loading completes
                // Set showListenButton first to ensure overlay stays visible, then hide loading bar
                // Use requestAnimationFrame to ensure smooth transition without flash
                requestAnimationFrame(() => {
                    state.loadingProgress.showListenButton = true;
                    // Ensure overlay opacity is set for fade out later
                    if (state.loadingProgress.overlayOpacity === undefined) {
                        state.loadingProgress.overlayOpacity = 0.7;
                    }
                    // Start button fade in (2 seconds)
                    state.loadingProgress.buttonOpacity = 0;
                    const startTime = performance.now();
                    const fadeInDuration = 2000; // 2 seconds
                    
                    const fadeIn = (currentTime) => {
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / fadeInDuration, 1);
                        state.loadingProgress.buttonOpacity = progress;
                        draw();
                        
                        if (progress < 1) {
                            requestAnimationFrame(fadeIn);
                        } else {
                            state.loadingProgress.buttonOpacity = 1;
                            draw();
                        }
                    };
                    
                    requestAnimationFrame(fadeIn);
                    
                    // Loading background GIF is already visible from loading bar phase
                    draw(); // Draw with button visible and loading bar still showing
                    requestAnimationFrame(() => {
                        state.loadingProgress.isLoading = false;
                        
                        // Set master volume to -60 dB when loading completes
                        // This ensures all sources will be silent when they start
                        if (state.masterGain) {
                            state.masterVolume = -60;
                            state.masterGain.gain.value = dbToLin(-60);
                            
                            // Update UI
                            const masterVolTab = document.getElementById('masterVol');
                            const masterVolValue = document.getElementById('masterVolValue');
                            if (masterVolTab) masterVolTab.value = -60;
                            if (masterVolValue) masterVolValue.textContent = '-60.0';
                        }
                        
                        draw(); // Now hide loading bar, overlay stays because showListenButton is true
                    });
                });
            } else {
                console.log('[Auto-load] No audio files found. Make sure files are named like A1.mp3, A2.wav, etc.');
                // Hide loading bar even if no files loaded
                state.loadingProgress.isLoading = false;
                
                // Set master volume to -60 dB even if no files loaded
                if (state.masterGain) {
                    state.masterVolume = -60;
                    state.masterGain.gain.value = dbToLin(-60);
                    
                    // Update UI
                    const masterVolTab = document.getElementById('masterVol');
                    const masterVolValue = document.getElementById('masterVolValue');
                    if (masterVolTab) masterVolTab.value = -60;
                    if (masterVolValue) masterVolValue.textContent = '-60.0';
                }
            }
        }
        
        // Ring snapping
        function snapToNearestRing(x, y, useFixedRadius = false) {
            if (!state.snapToRings) return { x, y };
            
            const dx = x - state.ringCenter.x;
            const dy = y - state.ringCenter.y;
            const angle = Math.atan2(dy, dx); // Always use current mouse angle
            
            // Use fixed radius from drag start if available
            let radius;
            if (useFixedRadius && state.dragStartRadius !== null) {
                radius = state.dragStartRadius;
            } else {
                // Calculate current distance and snap to nearest ring
                const currentDist = Math.sqrt(dx * dx + dy * dy);
                let nearestRadius = state.ringRadii[0];
                let minDiff = Math.abs(currentDist - nearestRadius);
                
                for (const r of state.ringRadii) {
                    const diff = Math.abs(currentDist - r);
                    if (diff < minDiff) {
                        minDiff = diff;
                        nearestRadius = r;
                    }
                }
                radius = nearestRadius;
            }
            
            const snappedX = state.ringCenter.x + Math.cos(angle) * radius;
            const snappedY = state.ringCenter.y + Math.sin(angle) * radius;
            
            return {
                x: clamp(snappedX, 0, 240),
                y: clamp(snappedY, 0, 240)
            };
        }
        
        // Audio setup
        function initAudio() {
            if (state.audioCtx) return;
            
            state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            state.masterGain = state.audioCtx.createGain();
            
            // Create compressor for master output
            state.masterCompressor = state.audioCtx.createDynamicsCompressor();
            state.masterCompressor.threshold.value = -25; // -25 dB threshold
            state.masterCompressor.ratio.value = 1.5; // 1.5:1 ratio
            state.masterCompressor.attack.value = 0.05; // 50 ms attack
            state.masterCompressor.release.value = 0.34; // 340 ms release
            state.masterCompressor.knee.value = 0; // Hard knee
            
            // Create makeup gain (+3 dB after compressor)
            state.masterMakeupGain = state.audioCtx.createGain();
            state.masterMakeupGain.gain.value = dbToLin(3); // +3 dB makeup gain
            
            // Create analyser for volume meter
            state.masterAnalyser = state.audioCtx.createAnalyser();
            state.masterAnalyser.fftSize = 2048;
            state.masterAnalyser.smoothingTimeConstant = 0.3;
            
            // Connect: masterGain -> compressor -> makeupGain -> analyser -> destination
            state.masterGain.connect(state.masterCompressor);
            state.masterCompressor.connect(state.masterMakeupGain);
            state.masterMakeupGain.connect(state.masterAnalyser);
            state.masterAnalyser.connect(state.audioCtx.destination);
            
            // Set initial master volume to -60 dB
            state.masterVolume = -60;
            state.masterGain.gain.value = dbToLin(state.masterVolume);
            
            // Update UI to show -60 dB
            const masterVolTab = document.getElementById('masterVol');
            const masterVolValue = document.getElementById('masterVolValue');
            if (masterVolTab) masterVolTab.value = state.masterVolume;
            if (masterVolValue) masterVolValue.textContent = state.masterVolume.toFixed(1);
        }
        
        // Toggle compressor on/off by bypassing it
        function toggleCompressor(enabled) {
            if (!state.masterGain || !state.masterCompressor || !state.masterMakeupGain || !state.masterAnalyser) {
                return;
            }
            
            // Disconnect all connections from masterGain
            state.masterGain.disconnect();
            
            // Disconnect compressor chain if it exists
            state.masterCompressor.disconnect();
            state.masterMakeupGain.disconnect();
            
            if (enabled) {
                // Compressor ON: masterGain -> compressor -> makeupGain -> analyser -> destination
                state.masterGain.connect(state.masterCompressor);
                state.masterCompressor.connect(state.masterMakeupGain);
                state.masterMakeupGain.connect(state.masterAnalyser);
            } else {
                // Compressor OFF: masterGain -> analyser -> destination (bypass compressor and makeup gain)
                state.masterGain.connect(state.masterAnalyser);
            }
            
            // Ensure analyser is connected to destination
            try {
                state.masterAnalyser.connect(state.audioCtx.destination);
            } catch (e) {
                // Already connected, ignore
            }
        }
        
        async function startAudio() {
            if (!state.audioCtx) {
                initAudio();
            }
            
            // Ensure audio context exists
            if (!state.audioCtx) {
                console.warn('Cannot start audio: audio context not available');
                return false;
            }
            
            // Resume audio context if suspended (required for autoplay policy)
            if (state.audioCtx.state === 'suspended') {
                try {
                    const resumePromise = state.audioCtx.resume();
                    await resumePromise;
                    console.log('[Audio] Audio context resumed successfully');
                } catch (err) {
                    console.warn('[Audio] Failed to resume audio context:', err);
                    // Try again after a short delay
                    try {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        if (state.audioCtx.state === 'suspended') {
                            await state.audioCtx.resume();
                            console.log('[Audio] Audio context resumed on retry');
                        }
                    } catch (retryErr) {
                        console.warn('[Audio] Retry resume also failed:', retryErr);
                        // Continue anyway - might work on user interaction
                    }
                }
            }
            
            // Check if audio context is actually running
            if (state.audioCtx.state !== 'running') {
                console.warn(`[Audio] Audio context state is ${state.audioCtx.state}, may require user interaction`);
                // Try one more time to resume
                if (state.audioCtx.state === 'suspended') {
                    try {
                        await state.audioCtx.resume();
                        console.log('[Audio] Audio context resumed after state check');
                    } catch (err) {
                        console.warn('[Audio] Final resume attempt failed:', err);
                    }
                }
            }
            
            // Set master volume to -60 dB BEFORE starting sources to prevent any sound
            const fadeStartDb = -60;
            const fadeEndDb = 0;
            const fadeDuration = 3.0; // 3 seconds
            
            if (state.masterGain) {
                // Immediately set to -60 dB before starting any sources
                state.masterVolume = fadeStartDb;
                state.masterGain.gain.value = dbToLin(fadeStartDb);
                
                // Update UI immediately
                const masterVolTab = document.getElementById('masterVol');
                const masterVolValue = document.getElementById('masterVolValue');
                if (masterVolTab) masterVolTab.value = fadeStartDb;
                if (masterVolValue) masterVolValue.textContent = fadeStartDb.toFixed(1);
            }
            
            // Set isPlaying to true BEFORE starting sources
            // This allows startSource to work (it checks isPlaying)
            state.isPlaying = true;
            
            // Start all sources with audio buffers (they will be silent at -60 dB)
            let startedCount = 0;
            for (const source of state.sources) {
                if (source.audioBuffer && !source.sourceNode) {
                    startSource(source);
                    startedCount++;
                }
            }
            
            // Always start fade in when Start button is pressed (even if no new sources started)
            // Master volume fade in: -60 dB to 0 dB over 3 seconds
            if (state.masterGain) {
                // Fade to 0 dB over 3 seconds
                const now = state.audioCtx.currentTime;
                const targetGain = dbToLin(fadeEndDb);
                state.masterGain.gain.setTargetAtTime(targetGain, now, fadeDuration);
                
                // Update state.masterVolume gradually (for UI display and meter)
                const fadeStartTime = performance.now();
                const updateVolume = () => {
                    const elapsed = (performance.now() - fadeStartTime) / 1000;
                    const progress = Math.min(elapsed / fadeDuration, 1);
                    const currentDb = fadeStartDb + (fadeEndDb - fadeStartDb) * progress;
                    state.masterVolume = currentDb;
                    
                    // Update UI
                    const masterVolTab = document.getElementById('masterVol');
                    const masterVolValue = document.getElementById('masterVolValue');
                    if (masterVolTab) masterVolTab.value = currentDb;
                    if (masterVolValue) masterVolValue.textContent = currentDb.toFixed(1);
                    
                    // Update master volume meter
                    updateMasterVolumeMeter();
                    
                    if (progress < 1) {
                        requestAnimationFrame(updateVolume);
                    } else {
                        // Fade complete
                        state.masterVolume = fadeEndDb;
                        if (masterVolTab) masterVolTab.value = fadeEndDb;
                        if (masterVolValue) masterVolValue.textContent = fadeEndDb.toFixed(1);
                        updateMasterVolumeMeter();
                    }
                };
                requestAnimationFrame(updateVolume);
            }
            
            updateAudioStatus();
            console.log(`[Audio] Started ${startedCount} sources with master volume fade in`);
            return true;
        }
        
        // Centralized auto-start function to avoid race conditions
        async function attemptAutoStart() {
            // DISABLED: Only start audio when Start button is pressed
            // This prevents any sound from playing before user clicks Start
            console.log('[Auto-start] attemptAutoStart() called but disabled - audio will only start when Start button is pressed');
            return;
            
            console.log('[Auto-start] attemptAutoStart() called');
            
            // Check if we have any audio buffers loaded
            const hasAudio = state.sources.some(s => s.audioBuffer);
            console.log(`[Auto-start] hasAudio: ${hasAudio}, isPlaying: ${state.isPlaying}, autoStartAttempted: ${state.autoStartAttempted}`);
            
            if (!hasAudio) {
                console.log('[Auto-start] No audio files loaded yet, skipping auto-start');
                return;
            }
            
            // If already playing, don't attempt again
            if (state.isPlaying) {
                console.log('[Auto-start] Audio already playing, skipping');
                return;
            }
            
            // Only attempt once per session (unless explicitly reset)
            if (state.autoStartAttempted) {
                console.log('[Auto-start] Already attempted, skipping');
                return;
            }
            
            // Mark as attempted
            state.autoStartAttempted = true;
            
            // Ensure audio context is ready
            if (!state.audioCtx) {
                try {
                    initAudio();
                } catch (err) {
                    console.warn('[Auto-start] Failed to init audio context:', err);
                    state.autoStartAttempted = false; // Allow retry
                    return;
                }
            }
            
            // Wait a bit for everything to settle (especially audio context)
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Double-check audio context is ready
            if (!state.audioCtx || state.audioCtx.state === 'closed') {
                console.warn('[Auto-start] Audio context not ready');
                state.autoStartAttempted = false; // Allow retry
                return;
            }
            
            // Try to resume audio context first (browser autoplay policy)
            if (state.audioCtx.state === 'suspended') {
                console.log('[Auto-start] Audio context is suspended, attempting to resume...');
                try {
                    // Use Promise.race with timeout to avoid hanging
                    const resumePromise = state.audioCtx.resume();
                    const timeoutPromise = new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Resume timeout')), 1000)
                    );
                    
                    await Promise.race([resumePromise, timeoutPromise]);
                    console.log('[Auto-start] ✓ Audio context resumed successfully');
                    console.log(`[Auto-start] Audio context state after resume: ${state.audioCtx.state}`);
                } catch (err) {
                    console.warn('[Auto-start] ✗ Failed to resume audio context:', err.message || err);
                    console.warn('[Auto-start] Audio context will remain suspended until user interaction');
                    // Continue anyway - startAudio() will try to resume again
                }
            }
            
            // Wait a bit more after resume
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Check audio context state again
            console.log(`[Auto-start] Audio context state before start: ${state.audioCtx.state}`);
            
            // Try to start
            console.log('[Auto-start] Attempting to start audio...');
            console.log(`[Auto-start] Sources with audio: ${state.sources.filter(s => s.audioBuffer).length}`);
            
            try {
                const success = await startAudio();
                console.log(`[Auto-start] startAudio() returned: ${success}`);
                if (success) {
                    console.log('[Auto-start] ✓ Audio started successfully');
                } else {
                    console.warn('[Auto-start] ✗ Audio start returned false');
                    // Check if audio context is still suspended
                    if (state.audioCtx && state.audioCtx.state === 'suspended') {
                        console.warn('[Auto-start] Audio context still suspended - will require user interaction');
                        console.warn('[Auto-start] User can click on canvas to start audio');
                    }
                    state.autoStartAttempted = false; // Allow retry
                }
            } catch (err) {
                console.error('[Auto-start] ✗ Failed to start audio:', err);
                state.autoStartAttempted = false; // Allow retry on error
            }
        }
        
        function stopAudio() {
            if (!state.audioCtx) return;
            
            for (const source of state.sources) {
                if (source.sourceNode) {
                    source.sourceNode.stop();
                    source.sourceNode = null;
                }
            }
            
            state.audioCtx.suspend();
            state.isPlaying = false;
            updateAudioStatus();
        }
        
        function startSource(source) {
            if (!state.audioCtx || !source.audioBuffer) return;
            
            // CRITICAL: Only start sources when isPlaying is true (Start button pressed)
            // This prevents any sound from playing before user clicks Start
            if (!state.isPlaying) {
                console.log(`[startSource] Skipping ${source.id} - audio not playing yet`);
                return;
            }
            
            // Ensure master volume is at -60 dB before starting source
            // This prevents any sound from playing
            if (state.masterGain && state.masterVolume > -60) {
                state.masterVolume = -60;
                state.masterGain.gain.value = dbToLin(-60);
            }
            
            const sourceNode = state.audioCtx.createBufferSource();
            sourceNode.buffer = source.audioBuffer;
            sourceNode.loop = true;
            
            const gainNode = state.audioCtx.createGain();
            const pannerNode = state.audioCtx.createStereoPanner();
            
            sourceNode.connect(gainNode);
            gainNode.connect(pannerNode);
            pannerNode.connect(state.masterGain);
            
            source.sourceNode = sourceNode;
            source.gainNode = gainNode;
            source.pannerNode = pannerNode;
            
            // Set initial gain to 0 to ensure silence
            gainNode.gain.value = 0;
            gainNode.gain.setValueAtTime(0, state.audioCtx.currentTime);
            pannerNode.pan.value = 0;
            
            sourceNode.start(0);
        }
        
        function updateSourceAudio(source, isInNearestN) {
            if (!state.isPlaying || !source.gainNode) return;
            
            const d = distance(state.listener.x, state.listener.y, source.x, source.y);
            const dx = source.x - state.listener.x;
            
            // Calculate target gain
            let targetGain = 0;
            if (isInNearestN && d < source.rmax) {
                const normalized = 1 - (d / source.rmax);
                const curved = Math.pow(normalized, source.falloffPower);
                const gainMaxLinear = dbToLin(-4);
                targetGain = curved * gainMaxLinear;
            }
            
            // Check if any source is solo
            const hasSolo = state.sources.some(s => s.solo);
            
            // Apply mute/solo logic
            if (hasSolo) {
                // If any source is solo, only solo sources play
                if (!source.solo) {
                    targetGain = 0;
                }
            } else {
                // If no solo, apply mute normally
                if (source.muted) {
                    targetGain = 0;
                }
            }
            
            // Apply fade multiplier for X1 (fade in/out)
            if (source.id === 'X1' && source.fadeMultiplier !== undefined) {
                targetGain *= source.fadeMultiplier;
            }
            
            // Apply T/X mute multiplier (A1/B1/B6 level-based mute)
            let gainBeforeMute = targetGain;
            if ((source.id === 'T1' || source.id === 'X1') && source.txMuteMultiplier !== undefined) {
                targetGain *= source.txMuteMultiplier;
                
                // Debug: log X1 gain calculation
                if (source.id === 'X1' && Math.random() < 0.02) {
                    console.log(`[X1 Gain] Before mute: ${gainBeforeMute.toFixed(4)}, txMuteMultiplier: ${source.txMuteMultiplier.toFixed(3)}, After mute: ${targetGain.toFixed(4)}`);
                }
            }
            
            // Smooth gain update (use source-specific smoothness)
            const now = state.audioCtx.currentTime;
            const smoothness = source.gainSmoothness !== undefined ? source.gainSmoothness : 0.05;
            source.gainNode.gain.setTargetAtTime(targetGain, now, smoothness);
            
            // Calculate pan
            if (state.panningEnabled) {
                const pan = clamp(dx / state.panDistance, -1, 1);
                source.pannerNode.pan.setTargetAtTime(pan, now, 0.05);
            } else {
                source.pannerNode.pan.setTargetAtTime(0, now, 0.05);
            }
        }
        
        function updateAllAudio() {
            if (!state.isPlaying) return;
            
            // Get all sources with audio, compute distances and sort
            const sourcesWithAudio = state.sources
                .map((source, index) => ({
                    source,
                    index,
                    distance: distance(state.listener.x, state.listener.y, source.x, source.y)
                }))
                .filter(item => item.source.audioBuffer && item.source.gainNode)
                .sort((a, b) => a.distance - b.distance);
            
            // Mark which sources are in nearest N
            const nearestNIndices = new Set();
            for (let i = 0; i < Math.min(state.nearestN, sourcesWithAudio.length); i++) {
                nearestNIndices.add(sourcesWithAudio[i].index);
            }
            
            // Check A1, B1, and B6 levels to determine T/X mute state
            // A1 and B1 affect both T1 and X1
            // B6 only affects X1
            // Calculate target gain for A1, B1, and B6
            const a1Source = state.sources.find(s => s.id === 'A1');
            const b1Source = state.sources.find(s => s.id === 'B1');
            const b6Source = state.sources.find(s => s.id === 'B6');
            const thresholdDb = -20;
            const thresholdLinear = dbToLin(thresholdDb);
            
            let shouldMuteTX = false; // For T1 and X1 (A1/B1 control)
            let shouldMuteX1 = false; // For X1 only (B6 control)
            
            // Calculate A1 target gain
            if (a1Source && a1Source.audioBuffer && a1Source.gainNode) {
                const a1Index = state.sources.indexOf(a1Source);
                const isA1InNearestN = nearestNIndices.has(a1Index);
                const dA1 = distance(state.listener.x, state.listener.y, a1Source.x, a1Source.y);
                let a1TargetGain = 0;
                if (isA1InNearestN && dA1 < a1Source.rmax) {
                    const normalized = 1 - (dA1 / a1Source.rmax);
                    const curved = Math.pow(normalized, a1Source.falloffPower);
                    const gainMaxLinear = dbToLin(-4);
                    a1TargetGain = curved * gainMaxLinear;
                }
                // Check mute/solo
                const hasSolo = state.sources.some(s => s.solo);
                if (hasSolo && !a1Source.solo) {
                    a1TargetGain = 0;
                } else if (!hasSolo && a1Source.muted) {
                    a1TargetGain = 0;
                }
                
                if (a1TargetGain > thresholdLinear) {
                    shouldMuteTX = true;
                }
            }
            
            // Calculate B1 target gain
            if (!shouldMuteTX && b1Source && b1Source.audioBuffer && b1Source.gainNode) {
                const b1Index = state.sources.indexOf(b1Source);
                const isB1InNearestN = nearestNIndices.has(b1Index);
                const dB1 = distance(state.listener.x, state.listener.y, b1Source.x, b1Source.y);
                let b1TargetGain = 0;
                if (isB1InNearestN && dB1 < b1Source.rmax) {
                    const normalized = 1 - (dB1 / b1Source.rmax);
                    const curved = Math.pow(normalized, b1Source.falloffPower);
                    const gainMaxLinear = dbToLin(-4);
                    b1TargetGain = curved * gainMaxLinear;
                }
                // Check mute/solo
                const hasSolo = state.sources.some(s => s.solo);
                if (hasSolo && !b1Source.solo) {
                    b1TargetGain = 0;
                } else if (!hasSolo && b1Source.muted) {
                    b1TargetGain = 0;
                }
                
                if (b1TargetGain > thresholdLinear) {
                    shouldMuteTX = true;
                }
            }
            
            // Check B6 distance (only for X1)
            // If listener is within 30 units of B6, mute X1
            if (b6Source) {
                const dB6 = distance(state.listener.x, state.listener.y, b6Source.x, b6Source.y);
                if (dB6 < 30) {
                    shouldMuteX1 = true;
                }
                // Debug: log B6 distance occasionally
                if (Math.random() < 0.02) { // 2% chance
                    console.log(`[B6 Distance Check] B6 pos: (${b6Source.x.toFixed(1)}, ${b6Source.y.toFixed(1)}), Listener pos: (${state.listener.x.toFixed(1)}, ${state.listener.y.toFixed(1)}), Distance: ${dB6.toFixed(2)}, shouldMuteX1: ${shouldMuteX1}`);
                }
            } else {
                // Debug: B6 not found
                if (Math.random() < 0.01) {
                    console.warn('[B6 Distance Check] B6 source not found!');
                }
            }
            
            // Update T/X mute multiplier with smooth fade
            const fadeTimeConstant = 0.05; // Time constant for fade in/out (seconds) - faster for more responsive muting
            const currentTime = performance.now() / 1000;
            let dt = (currentTime - (state.lastTXMuteUpdate || currentTime));
            // Ensure dt is reasonable (cap at 0.1 seconds to prevent huge jumps)
            if (dt > 0.1) dt = 0.1;
            // dt is already in seconds (performance.now() returns milliseconds, we divide by 1000 above)
            state.lastTXMuteUpdate = currentTime;
            
            // Update T1 and X1 mute multipliers
            const t1Source = state.sources.find(s => s.id === 'T1');
            const x1Source = state.sources.find(s => s.id === 'X1');
            
            if (t1Source) {
                if (t1Source.txMuteMultiplier === undefined) {
                    t1Source.txMuteMultiplier = 1; // Initialize to 1 (not muted)
                }
                const targetMultiplier = shouldMuteTX ? 0 : 1;
                const currentMultiplier = t1Source.txMuteMultiplier;
                
                // Smooth exponential transition
                if (Math.abs(currentMultiplier - targetMultiplier) > 0.001) {
                    const smoothingFactor = 1 - Math.exp(-dt / fadeTimeConstant);
                    t1Source.txMuteMultiplier = currentMultiplier + (targetMultiplier - currentMultiplier) * smoothingFactor;
                    t1Source.txMuteMultiplier = clamp(t1Source.txMuteMultiplier, 0, 1);
                } else {
                    t1Source.txMuteMultiplier = targetMultiplier;
                }
            }
            
            if (x1Source) {
                if (x1Source.txMuteMultiplier === undefined) {
                    x1Source.txMuteMultiplier = 1; // Initialize to 1 (not muted)
                }
                // X1: affected by A1/B1 (shouldMuteTX) OR B6 (shouldMuteX1)
                const targetMultiplier = (shouldMuteTX || shouldMuteX1) ? 0 : 1;
                const currentMultiplier = x1Source.txMuteMultiplier;
                
                // Debug: log X1 mute state
                if (Math.random() < 0.02) { // 2% chance
                    console.log(`[X1 Mute] shouldMuteTX: ${shouldMuteTX}, shouldMuteX1: ${shouldMuteX1}, targetMultiplier: ${targetMultiplier}, currentMultiplier: ${currentMultiplier.toFixed(3)}, txMuteMultiplier: ${x1Source.txMuteMultiplier.toFixed(3)}`);
                }
                
                // If muting (targetMultiplier === 0), apply faster fade or direct mute
                if (targetMultiplier === 0) {
                    // Use faster fade for muting
                    const muteFadeTimeConstant = 0.02; // Even faster for muting
                    if (Math.abs(currentMultiplier - targetMultiplier) > 0.001) {
                        const smoothingFactor = 1 - Math.exp(-dt / muteFadeTimeConstant);
                        x1Source.txMuteMultiplier = currentMultiplier + (targetMultiplier - currentMultiplier) * smoothingFactor;
                        x1Source.txMuteMultiplier = clamp(x1Source.txMuteMultiplier, 0, 1);
                        
                        // If very close to 0, set to 0 directly for complete silence
                        if (x1Source.txMuteMultiplier < 0.01) {
                            x1Source.txMuteMultiplier = 0;
                        }
                    } else {
                        x1Source.txMuteMultiplier = 0;
                    }
                } else {
                    // Normal fade for unmuting
                    if (Math.abs(currentMultiplier - targetMultiplier) > 0.001) {
                        const smoothingFactor = 1 - Math.exp(-dt / fadeTimeConstant);
                        x1Source.txMuteMultiplier = currentMultiplier + (targetMultiplier - currentMultiplier) * smoothingFactor;
                        x1Source.txMuteMultiplier = clamp(x1Source.txMuteMultiplier, 0, 1);
                    } else {
                        x1Source.txMuteMultiplier = targetMultiplier;
                    }
                }
            } else {
                // Debug: X1 not found
                if (Math.random() < 0.01) {
                    console.warn('[X1 Mute] X1 source not found!');
                }
            }
            
            // Update all sources
            for (let i = 0; i < state.sources.length; i++) {
                const source = state.sources[i];
                if (source.audioBuffer && source.gainNode) {
                    updateSourceAudio(source, nearestNIndices.has(i));
                }
            }
        }
        
        // Update visual alpha for all sources (smooth fade)
        function updateVisualAlpha() {
            const currentTime = performance.now();
            const dt = (currentTime - state.lastFrameTime) / 1000; // Convert to seconds
            state.lastFrameTime = currentTime;
            
            // Get all sources with audio, compute distances and sort
            const sourcesWithAudio = state.sources
                .map((source, index) => ({
                    source,
                    index,
                    distance: distance(state.listener.x, state.listener.y, source.x, source.y)
                }))
                .filter(item => item.source.audioBuffer)
                .sort((a, b) => a.distance - b.distance);
            
            // Mark which sources are in nearest N
            const nearestNIndices = new Set();
            for (let i = 0; i < Math.min(state.nearestN, sourcesWithAudio.length); i++) {
                nearestNIndices.add(sourcesWithAudio[i].index);
            }
            
            // Update visual alpha for all sources
            for (let i = 0; i < state.sources.length; i++) {
                const source = state.sources[i];
                if (!source.audioBuffer) {
                    source.visualAlpha = 0;
                    continue;
                }
                
                const d = distance(state.listener.x, state.listener.y, source.x, source.y);
                
                // Calculate target alpha
                let visualAlphaTarget = 0;
                if (nearestNIndices.has(i) && d < source.rmax) {
                    const normalized = clamp(1 - (d / source.rmax), 0, 1);
                    visualAlphaTarget = Math.pow(normalized, state.visualPower);
                }
                
                // Smooth the alpha with exponential smoothing
                const smoothingFactor = 1 - Math.exp(-dt / state.visualTau);
                source.visualAlpha += (visualAlphaTarget - source.visualAlpha) * smoothingFactor;
            }
        }
        
        // Drawing - all coordinates in world space (0..240)
        function draw() {
            if (!ctx || !canvas) {
                console.warn('Canvas not initialized, skipping draw');
                return;
            }
            
            // Increment frame counter
            state.framesDrawn++;
            
            // Update debug overlay
            updateDebugOverlay();
            
            // Clear entire canvas
            const pixelSize = state.canvasPixelSize || 240;
            ctx.clearRect(0, 0, pixelSize, pixelSize);
            
            // Set transform: scale world coordinates (0..240) to fill canvas pixels
            const scale = state.scale > 0 ? state.scale : 1;
            ctx.setTransform(scale, 0, 0, scale, 0, 0);
            
            // Draw background image in world space
            const bgImg = state.bgImage.image;
            if (bgImg && bgImg.complete && bgImg.naturalWidth > 0) {
                // Image is loaded and ready - draw it
                ctx.drawImage(bgImg, 0, 0, state.worldSize, state.worldSize);
                
                // Draw "BG LOADED" badge in debug mode
                if (state.debugVisuals) {
                    ctx.fillStyle = 'rgba(0, 204, 51, 0.7)';
                    ctx.fillRect(5, 5, 70, 15);
                    ctx.fillStyle = '#000';
                    ctx.font = '10px sans-serif';
                    ctx.fillText('BG LOADED', 8, 16);
                }
            } else {
                // Draw placeholder: checkerboard pattern
                const checkerSize = 10;
                for (let y = 0; y < state.worldSize; y += checkerSize) {
                    for (let x = 0; x < state.worldSize; x += checkerSize) {
                        const isEven = ((x / checkerSize) + (y / checkerSize)) % 2 === 0;
                        ctx.fillStyle = isEven ? '#1a1a1a' : '#2a2a2a';
                        ctx.fillRect(x, y, checkerSize, checkerSize);
                    }
                }
                
                // Draw subtle status text (non-fatal, small)
                if (state.bgImage.status === 'ERROR') {
                    ctx.fillStyle = 'rgba(204, 51, 0, 0.5)';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('BG: ' + (state.bgImage.errorMessage || 'Error'), state.worldSize / 2, state.worldSize - 10);
                }
                ctx.textAlign = 'left';
                ctx.textBaseline = 'alphabetic';
            }
            
            // Draw ring center marker (bottom-right) in world space
            if (state.debugVisuals) {
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(state.ringCenter.x, state.ringCenter.y, 3, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Check if any source is solo
            const hasSolo = state.sources.some(s => s.solo);
            
            // Draw sources in world space (only if showSources is enabled)
            if (state.showSources) {
                for (let i = 0; i < state.sources.length; i++) {
                    const source = state.sources[i];
                    
                    // Determine if this source should show range circles
                    // Don't show if muted, and respect solo logic
                    const shouldShowRange = state.showSourceRanges && source.audioBuffer && 
                        !source.muted && (!hasSolo || source.solo);
                
                // Draw audible radius with smooth fade
                if (shouldShowRange) {
                    // Draw subtle gray inactive ring (constant, low opacity)
                    ctx.strokeStyle = 'rgba(102, 102, 102, 0.2)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.arc(source.x, source.y, source.rmax, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Draw active ring with smooth alpha fade (yellow if solo, green otherwise)
                    let alpha = clamp(source.visualAlpha || 0, 0, 1);
                    // Apply fade multiplier for X1
                    if (source.id === 'X1' && source.fadeMultiplier !== undefined) {
                        alpha *= source.fadeMultiplier;
                    }
                    if (alpha > 0.01) {
                        if (source.solo) {
                            ctx.strokeStyle = `rgba(255, 255, 0, ${alpha})`; // Yellow for solo
                        } else {
                            ctx.strokeStyle = `rgba(0, 255, 0, ${alpha})`; // Green for normal
                        }
                        ctx.lineWidth = 1;
                        ctx.setLineDash([2, 2]);
                        ctx.beginPath();
                        ctx.arc(source.x, source.y, source.rmax, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                }
                
                // Draw source point (yellow if solo, orange if has audio, gray otherwise)
                // Apply 50% opacity if muted
                let fillColor;
                if (source.solo) {
                    fillColor = '#ffff00'; // Yellow for solo
                } else if (source.audioBuffer) {
                    fillColor = '#04427b'; // Dark blue for normal
                } else {
                    fillColor = '#666'; // Gray for no audio
                }
                
                // Apply opacity if muted or X1 fade
                let sourceOpacity = 1.0;
                if (source.muted) {
                    sourceOpacity = 0.5;
                }
                // Apply fade multiplier for X1
                if (source.id === 'X1' && source.fadeMultiplier !== undefined) {
                    sourceOpacity *= source.fadeMultiplier;
                }
                ctx.globalAlpha = sourceOpacity;
                
                ctx.fillStyle = fillColor;
                ctx.beginPath();
                ctx.arc(source.x, source.y, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Reset global alpha
                ctx.globalAlpha = 1.0;
                
                // Draw label (A1, A2, B1, B2, etc.) if enabled
                if (state.showSourceLabels) {
                    const labelText = source.id;
                    // Apply opacity if muted or X1 fade
                    let labelOpacity = 1.0;
                    if (source.muted) {
                        labelOpacity = 0.5;
                    }
                    // Apply fade multiplier for X1
                    if (source.id === 'X1' && source.fadeMultiplier !== undefined) {
                        labelOpacity *= source.fadeMultiplier;
                    }
                    ctx.globalAlpha = labelOpacity;
                    ctx.fillStyle = '#fff';
                    ctx.font = '8px sans-serif';
                    // Add subtle outline for readability
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.lineJoin = 'round';
                    ctx.miterLimit = 2;
                    ctx.strokeText(labelText, source.x + 6, source.y - 6);
                    ctx.fillText(labelText, source.x + 6, source.y - 6);
                    // Reset global alpha
                    ctx.globalAlpha = 1.0;
                }
                
                // Draw line to listener if debug (with smooth alpha fade)
                if (state.debugVisuals && source.audioBuffer) {
                    let alpha = clamp(source.visualAlpha || 0, 0, 1);
                    // Apply fade multiplier for X1
                    if (source.id === 'X1' && source.fadeMultiplier !== undefined) {
                        alpha *= source.fadeMultiplier;
                    }
                    if (alpha > 0.01) {
                        ctx.strokeStyle = `rgba(0, 255, 0, ${alpha * 0.5})`;
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        ctx.moveTo(source.x, source.y);
                        ctx.lineTo(state.listener.x, state.listener.y);
                        ctx.stroke();
                    }
                }
                }
            }
            
            // Draw listener in world space (current position, always on top)
            ctx.fillStyle = '#00ff00';
            ctx.beginPath();
            ctx.arc(state.listener.x, state.listener.y, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Reset transform
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            
            // Loading background GIF is handled via HTML img element overlay (for animation support)
            
            // Draw overlay if loading, showing listen button, or fading out (keeps dark background until fade completes)
            let overlayOpacity = state.loadingProgress.overlayOpacity;
            if (overlayOpacity === undefined) {
                // Use default opacity if not set
                overlayOpacity = (state.loadingProgress.isLoading || state.loadingProgress.showListenButton) ? 0.7 : 0;
            }
            if (overlayOpacity > 0) {
                // Semi-transparent dark background (opacity fades out when listen button is clicked)
                ctx.fillStyle = `rgba(0, 0, 0, ${overlayOpacity})`;
                ctx.fillRect(0, 0, pixelSize, pixelSize);
            }
            
            // Draw loading bar overlay if loading
            if (state.loadingProgress.isLoading) {
                const loading = state.loadingProgress;
                const centerX = pixelSize / 2;
                const centerY = pixelSize / 2;
                
                // Loading bar container
                const barWidth = pixelSize * 0.6;
                const barHeight = 8;
                const barX = centerX - barWidth / 2;
                const barY = centerY - barHeight / 2;
                
                // Background bar (dark)
                ctx.fillStyle = 'rgba(40, 40, 40, 0.9)';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                // Progress bar (bright purple)
                const progressWidth = barWidth * loading.progress;
                if (progressWidth > 0) {
                    // Bright purple gradient
                    const gradient = ctx.createLinearGradient(barX, barY, barX + progressWidth, barY);
                    gradient.addColorStop(0, '#9d4edd'); // Bright purple
                    gradient.addColorStop(0.5, '#c77dff'); // Lighter purple
                    gradient.addColorStop(1, '#e0aaff'); // Very light purple
                    ctx.fillStyle = gradient;
                    ctx.fillRect(barX, barY, progressWidth, barHeight);
                    
                    // Add subtle glow effect
                    ctx.shadowColor = '#c77dff';
                    ctx.shadowBlur = 10;
                    ctx.fillRect(barX, barY, progressWidth, barHeight);
                    ctx.shadowBlur = 0;
                }
                
                // Border
                ctx.strokeStyle = 'rgba(200, 150, 255, 0.5)';
                ctx.lineWidth = 1;
                ctx.strokeRect(barX, barY, barWidth, barHeight);
            }
            
            // Draw "START THE EXPERIENCE" button if loading is complete
            if (state.loadingProgress.showListenButton) {
                const centerX = pixelSize / 2;
                const centerY = pixelSize / 2;
                const buttonOpacity = state.loadingProgress.buttonOpacity || 0;
                
                if (buttonOpacity > 0) {
                    // Apply opacity for both stripe and button
                    ctx.globalAlpha = buttonOpacity;
                    
                    // Button text (no background, just text with outline) - uppercase
                    const buttonText = 'START THE EXPERIENCE';
                    // Use Raleway font (thin, elegant) - always try Raleway first, fallback if not available
                    ctx.font = '300 32px "Raleway", Raleway, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Measure text to determine stripe height
                    const textMetrics = ctx.measureText(buttonText);
                    const textHeight = 32; // Approximate text height
                    const stripePadding = 12; // Padding above and below text
                    const stripeHeight = textHeight + stripePadding * 2;
                    
                    // Draw horizontal stripe behind button (canvas width, centered on button)
                    const stripeColor = '#1a0a1a'; // Dark purple, almost black
                    ctx.fillStyle = stripeColor;
                    ctx.fillRect(0, centerY - stripeHeight / 2, pixelSize, stripeHeight);
                    
                    // Enable high-quality text rendering (already set globally, but ensure it's active)
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    if (ctx.textRenderingOptimization) {
                        ctx.textRenderingOptimization = 'optimizeQuality';
                    }
                    
                    // Draw text outline (lighter color, thinner, no rounded joins)
                    ctx.strokeStyle = '#e0aaff'; // Lighter purple outline
                    ctx.lineWidth = 1.5; // Thinner stroke
                    ctx.lineJoin = 'miter'; // Sharp corners, not rounded
                    ctx.miterLimit = 2;
                    ctx.strokeText(buttonText, centerX, centerY);
                    
                    // Draw text fill (dark color)
                    ctx.fillStyle = '#1a1a1a'; // Dark color
                    ctx.fillText(buttonText, centerX, centerY);
                    
                    // Reset global alpha
                    ctx.globalAlpha = 1.0;
                }
            }
        }
        
        // Render loop (independent of audio, always runs)
        // Update master volume meter and gain reduction meter
        function updateMasterVolumeMeter() {
            if (!state.masterAnalyser || !state.isPlaying) {
                const bar = document.getElementById('masterVolumeBar');
                const value = document.getElementById('masterVolumeValue');
                const grBar = document.getElementById('gainReductionBar');
                const grValue = document.getElementById('gainReductionValue');
                if (bar) {
                    bar.style.width = '0%';
                    bar.style.background = '#00cc33';
                }
                if (value) value.textContent = '-∞ dB';
                if (grBar) {
                    grBar.style.width = '0%';
                }
                if (grValue) grValue.textContent = '0.0 dB';
                return;
            }
            
            // Update gain reduction meter
            if (state.masterCompressor) {
                const gainReduction = state.masterCompressor.reduction;
                const grBar = document.getElementById('gainReductionBar');
                const grValue = document.getElementById('gainReductionValue');
                
                if (grBar && grValue) {
                    // Gain reduction is negative (e.g., -3 dB means 3 dB reduction)
                    const reductionAbs = Math.abs(gainReduction);
                    // Scale to 0-100% (max 20 dB reduction shown)
                    const reductionPercent = Math.min((reductionAbs / 20) * 100, 100);
                    grBar.style.width = reductionPercent + '%';
                    grValue.textContent = gainReduction.toFixed(1) + ' dB';
                }
            }
            
            const dataArray = new Uint8Array(state.masterAnalyser.frequencyBinCount);
            state.masterAnalyser.getByteFrequencyData(dataArray);
            
            // Calculate RMS (root mean square) for volume level
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                const normalized = dataArray[i] / 255.0;
                sum += normalized * normalized;
            }
            const rms = Math.sqrt(sum / dataArray.length);
            
            // Convert to dB (0-255 range, -60dB to 0dB approximately)
            const db = rms > 0 ? 20 * Math.log10(rms) : -60;
            const normalizedDb = Math.max(0, Math.min(1, (db + 60) / 60)); // Normalize -60dB to 0dB as 0 to 1
            
            // Calculate color based on dB level with fade transitions
            let color;
            if (db < -12) {
                // -60 to -12: Green
                color = '#00cc33';
            } else if (db < -6) {
                // -12 to -6: Green to Yellow (fade)
                const t = (db + 12) / 6; // 0 to 1
                const r = Math.round(0 + t * 255);
                const g = Math.round(204 + t * 51);
                const b = Math.round(51 - t * 51);
                color = `rgb(${r}, ${g}, ${b})`;
            } else if (db < -2) {
                // -6 to -2: Yellow to Orange (fade)
                const t = (db + 6) / 4; // 0 to 1
                const r = Math.round(255);
                const g = Math.round(255 - t * 153); // 255 to 102
                const b = Math.round(0);
                color = `rgb(${r}, ${g}, ${b})`;
            } else {
                // -2 to 0: Orange to Red (fade)
                const t = (db + 2) / 2; // 0 to 1
                const r = Math.round(255);
                const g = Math.round(102 - t * 102); // 102 to 0
                const b = Math.round(0);
                color = `rgb(${r}, ${g}, ${b})`;
            }
            
            // Update UI
            const bar = document.getElementById('masterVolumeBar');
            const value = document.getElementById('masterVolumeValue');
            if (bar) {
                bar.style.width = (normalizedDb * 100) + '%';
                bar.style.background = color;
            }
            if (value) {
                value.textContent = db.toFixed(1) + ' dB';
            }
        }
        
        // Update listener position from tracking
        function updateTrackingPosition() {
            if (!state.tracking.enabled) return;
            
            if (state.tracking.mode === 'devicemotion') {
                // DeviceMotion tracking (basic dead reckoning - test only)
                // This is NOT ARKit - just basic motion tracking for testing
                // Real ARKit requires native iOS app (see ARKIT_INTEGRATION.md)
                updateDeviceMotionTracking();
            } else if (state.tracking.mode === 'arkit') {
                // ARKit tracking (native app only)
                // Position updates come from native app via window.updateListenerPosition()
                // This is just a placeholder in web version
            }
        }
        
        // DeviceMotion tracking (test only - not ARKit quality)
        function updateDeviceMotionTracking() {
            // This is basic dead reckoning - drift will occur
            // Real ARKit requires native iOS app
            if (!window.DeviceMotionEvent) {
                updateTrackingStatus('DeviceMotion not supported', false);
                return;
            }
        }
        
        // Update tracking status UI
        function updateTrackingStatus(message, isActive) {
            const statusText = document.getElementById('trackingStatusText');
            if (statusText) {
                statusText.textContent = message;
                statusText.style.color = isActive ? '#4a9' : '#888';
            }
        }
        
        // Enable/disable DeviceMotion tracking
        function enableDeviceMotionTracking() {
            if (!window.DeviceMotionEvent) {
                alert('DeviceMotion API is not supported on this device.');
                state.tracking.enabled = false;
                updateTrackingStatus('Not supported', false);
                return;
            }
            
            // Request permission (iOS 13+ requires user gesture)
            if (typeof DeviceMotionEvent.requestPermission === 'function') {
                DeviceMotionEvent.requestPermission().then(response => {
                    if (response === 'granted') {
                        startDeviceMotionTracking();
                    } else {
                        // Permission denied - show helpful message
                        const message = 'Motion tracking izni reddedildi.\n\n' +
                            'iOS\'ta izin vermek için:\n' +
                            '1. Ayarlar > Safari > Motion & Orientation Access\'i açın\n' +
                            '2. Sayfayı yenileyin ve tekrar deneyin\n\n' +
                            'Alternatif: Manual (Drag) modunu kullanabilirsiniz.';
                        alert(message);
                        state.tracking.enabled = false;
                        const enableCheckbox = document.getElementById('enableTracking');
                        if (enableCheckbox) {
                            enableCheckbox.checked = false;
                        }
                        updateTrackingStatus('Permission denied - Safari ayarlarından izin verin', false);
                    }
                }).catch(err => {
                    console.error('DeviceMotion permission error:', err);
                    state.tracking.enabled = false;
                    const enableCheckbox = document.getElementById('enableTracking');
                    if (enableCheckbox) {
                        enableCheckbox.checked = false;
                    }
                    updateTrackingStatus('Permission error', false);
                });
            } else {
                // Older browsers - permission not required
                startDeviceMotionTracking();
            }
        }
        
        function startDeviceMotionTracking() {
            state.tracking.enabled = true;
            state.tracking.lastPosition = { x: state.listener.x, y: state.listener.y };
            state.tracking.lastUpdateTime = performance.now() / 1000;
            updateTrackingStatus('Tracking... (Test mode - drift will occur)', true);
            
            window.addEventListener('devicemotion', handleDeviceMotion);
        }
        
        function handleDeviceMotion(event) {
            if (!state.tracking.enabled || state.tracking.mode !== 'devicemotion') return;
            
            const now = performance.now() / 1000;
            const dt = now - (state.tracking.lastUpdateTime || now);
            state.tracking.lastUpdateTime = now;
            
            if (dt <= 0 || dt > 0.1) return; // Skip invalid/infrequent updates
            
            // Basic dead reckoning (NOT accurate - test only)
            // Real ARKit requires native iOS app
            const accel = event.accelerationIncludingGravity;
            if (!accel) return;
            
            // Very basic integration (will drift significantly)
            // This is just for testing - real ARKit is much better
            const scale = 0.1; // Rough scaling factor (test only)
            const dx = accel.x * scale * dt * dt;
            const dy = -accel.y * scale * dt * dt; // Invert Y
            
            // Smooth and update
            const alpha = state.tracking.smoothingAlpha;
            let newX = state.tracking.lastPosition.x + dx;
            let newY = state.tracking.lastPosition.y + dy;
            
            // Clamp to world bounds
            newX = clamp(newX, 0, state.worldSize);
            newY = clamp(newY, 0, state.worldSize);
            
            // Smooth with exponential filter
            state.listener.x = alpha * newX + (1 - alpha) * state.listener.x;
            state.listener.y = alpha * newY + (1 - alpha) * state.listener.y;
            
            state.tracking.lastPosition = { x: state.listener.x, y: state.listener.y };
        }
        
        function disableDeviceMotionTracking() {
            state.tracking.enabled = false;
            window.removeEventListener('devicemotion', handleDeviceMotion);
            updateTrackingStatus('Disabled', false);
        }
        
        // ARKit position update (called from native app via JavaScript bridge)
        window.updateListenerPosition = function(x, y) {
            if (state.tracking.enabled && state.tracking.mode === 'arkit') {
                // Smooth update
                const alpha = state.tracking.smoothingAlpha;
                state.listener.x = alpha * x + (1 - alpha) * state.listener.x;
                state.listener.y = alpha * y + (1 - alpha) * state.listener.y;
                
                // Clamp to bounds
                state.listener.x = clamp(state.listener.x, 0, state.worldSize);
                state.listener.y = clamp(state.listener.y, 0, state.worldSize);
            }
        };
        
        function renderLoop() {
            // Update visual alpha (always, for smooth fading)
            updateVisualAlpha();
            
            // Update tracking position
            updateTrackingPosition();
            
            // Update T1 movement
            const t1Source = state.sources.find(s => s.id === 'T1');
            if (t1Source) {
                updateT1Movement(t1Source);
            }
            
            // Update X1 movement and fade
            const x1Source = state.sources.find(s => s.id === 'X1');
            if (x1Source) {
                updateX1Movement(x1Source);
                updateX1Fade(x1Source);
            }
            
            // Update master volume meter
            updateMasterVolumeMeter();
            
            draw();
            
            // Update audio if playing
            if (state.isPlaying) {
                updateAllAudio();
                updateReadout();
            }
            
            requestAnimationFrame(renderLoop);
        }
        
        // Animation loop (legacy, kept for compatibility)
        function animate() {
            if (!state.isPlaying) return;
            
            draw();
            
            // Update all source audio (with nearest N constraint)
            updateAllAudio();
            
            // Update readout
            updateReadout();
            
            requestAnimationFrame(animate);
        }
        
        // Update debug overlay
        function updateDebugOverlay() {
            const bgState = document.getElementById('debug-bgState');
            const bgSrc = document.getElementById('debug-bgSrc');
            const scale = document.getElementById('debug-scale');
            const canvasSize = document.getElementById('debug-canvasSize');
            const frames = document.getElementById('debug-frames');
            
            if (bgState) bgState.textContent = state.bgImage.status;
            if (bgSrc) bgSrc.textContent = state.bgImage.src || '-';
            if (scale) scale.textContent = state.scale.toFixed(2);
            if (canvasSize) canvasSize.textContent = state.canvasPixelSize;
            if (frames) frames.textContent = state.framesDrawn;
        }
        
        // Readout
        function updateReadout() {
            const readout = document.getElementById('readout');
            let text = `Listener: (${state.listener.x.toFixed(1)}, ${state.listener.y.toFixed(1)})\n\n`;
            
            // Get active sources
            const activeSources = state.sources
                .map((source, index) => ({
                    source,
                    index,
                    distance: distance(state.listener.x, state.listener.y, source.x, source.y)
                }))
                .filter(item => item.source.audioBuffer && item.source.gainNode)
                .sort((a, b) => a.distance - b.distance)
                .slice(0, state.nearestN);
            
            text += `Active Sources (${activeSources.length}):\n`;
            for (const item of activeSources) {
                const source = item.source;
                const currentGain = source.gainNode.gain.value;
                const targetGain = currentGain; // Approximate
                const pan = source.pannerNode.pan.value;
                
                text += `  ${source.id}:\n`;
                text += `    Dist: ${item.distance.toFixed(1)}\n`;
                text += `    Gain: ${targetGain.toFixed(3)} (${linToDb(targetGain).toFixed(1)} dB)\n`;
                text += `    Pan: ${pan.toFixed(2)}\n`;
            }
            
            readout.textContent = text;
        }
        
        // UI Updates
        function updateAudioStatus() {
            // Update tab status
            const status = document.getElementById('audioStatus');
            if (status) {
                status.textContent = state.isPlaying ? 'PLAYING' : 'STOPPED';
                status.className = 'status ' + (state.isPlaying ? 'playing' : 'stopped');
            }
            // Update HUD status
            const hudStatus = document.getElementById('hudStatus');
            if (hudStatus) {
                hudStatus.textContent = state.isPlaying ? 'PLAYING' : 'STOPPED';
                hudStatus.className = 'hud-status ' + (state.isPlaying ? 'playing' : 'stopped');
            }
        }
        
        function updateMixerList() {
            const list = document.getElementById('mixerList');
            if (!list) return;
            list.innerHTML = '';
            
            for (let i = 0; i < state.sources.length; i++) {
                const source = state.sources[i];
                const item = document.createElement('div');
                item.className = 'mixer-item';
                item.style.cssText = 'padding: 8px; margin-bottom: 5px; border: 1px solid #444; border-radius: 4px; background: #2a2a2a;';
                
                item.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <span style="font-weight: bold; color: ${source.solo ? '#ffff00' : '#fff'};">${source.id}</span>
                        <div style="display: flex; gap: 5px;">
                            <button class="mixer-mute" data-index="${i}" style="padding: 4px 12px; font-size: 11px; ${source.muted ? 'background: #ff4444;' : 'background: #555;'} color: #fff; border: none; border-radius: 3px; cursor: pointer;">
                                ${source.muted ? 'Unmute' : 'Mute'}
                            </button>
                            <button class="mixer-solo" data-index="${i}" style="padding: 4px 12px; font-size: 11px; ${source.solo ? 'background: #ffff00; color: #000;' : 'background: #555; color: #fff;'} border: none; border-radius: 3px; cursor: pointer;">
                                ${source.solo ? 'Unsolo' : 'Solo'}
                            </button>
                        </div>
                    </div>
                    <div style="margin-top: 8px;">
                        <label style="display: block; font-size: 11px; color: #ccc; margin-bottom: 4px;">Rmax: <span class="mixer-rmax-value-${i}">${source.rmax}</span></label>
                        <input type="range" class="mixer-rmax" data-index="${i}" min="20" max="200" value="${source.rmax}" step="5" style="width: 100%;">
                    </div>
                    <div style="margin-top: 8px;">
                        <label style="display: block; font-size: 11px; color: #ccc; margin-bottom: 4px;">Falloff Power: <span class="mixer-falloff-value-${i}">${source.falloffPower.toFixed(1)}</span></label>
                        <input type="range" class="mixer-falloff" data-index="${i}" min="0.5" max="5" value="${source.falloffPower}" step="0.1" style="width: 100%;">
                    </div>
                    <div style="margin-top: 8px;">
                        <label style="display: block; font-size: 11px; color: #ccc; margin-bottom: 4px;">Fade Smoothness: <span class="mixer-smoothness-value-${i}">${(source.gainSmoothness || 0.05).toFixed(2)}</span>s</label>
                        <input type="range" class="mixer-smoothness" data-index="${i}" min="0.01" max="1.0" value="${source.gainSmoothness || 0.05}" step="0.01" style="width: 100%;">
                    </div>
                `;
                
                list.appendChild(item);
            }
            
            // Attach event listeners
            document.querySelectorAll('.mixer-mute').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const index = parseInt(e.target.dataset.index);
                    state.sources[index].muted = !state.sources[index].muted;
                    updateMixerList();
                });
            });
            
            document.querySelectorAll('.mixer-solo').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const index = parseInt(e.target.dataset.index);
                    state.sources[index].solo = !state.sources[index].solo;
                    updateMixerList();
                });
            });
            
            document.querySelectorAll('.mixer-rmax').forEach(input => {
                input.addEventListener('input', (e) => {
                    const index = parseInt(e.target.dataset.index);
                    const value = parseFloat(e.target.value);
                    state.sources[index].rmax = value;
                    document.querySelector(`.mixer-rmax-value-${index}`).textContent = value;
                });
            });
            
            document.querySelectorAll('.mixer-falloff').forEach(input => {
                input.addEventListener('input', (e) => {
                    const index = parseInt(e.target.dataset.index);
                    const value = parseFloat(e.target.value);
                    state.sources[index].falloffPower = value;
                    document.querySelector(`.mixer-falloff-value-${index}`).textContent = value.toFixed(1);
                });
            });
            
            document.querySelectorAll('.mixer-smoothness').forEach(input => {
                input.addEventListener('input', (e) => {
                    const index = parseInt(e.target.dataset.index);
                    const value = parseFloat(e.target.value);
                    state.sources[index].gainSmoothness = value;
                    document.querySelector(`.mixer-smoothness-value-${index}`).textContent = value.toFixed(2) + 's';
                });
            });
        }
        
        function updateSourcesList() {
            const list = document.getElementById('sourcesList');
            list.innerHTML = '';
            
            for (let i = 0; i < state.sources.length; i++) {
                const source = state.sources[i];
                const item = document.createElement('div');
                item.className = 'source-item';
                if (source.audioBuffer && source.gainNode && source.gainNode.gain.value > 0.001) {
                    item.classList.add('active-source');
                }
                
                item.innerHTML = `
                    <div class="source-header">
                        <input type="text" class="source-name" value="${source.id}" data-index="${i}">
                        <div class="source-controls">
                            <button class="delete-source" data-index="${i}">Delete</button>
                        </div>
                    </div>
                    <div class="source-info">
                        Position: (${source.x.toFixed(1)}, ${source.y.toFixed(1)})
                    </div>
                    <div class="control-group">
                        <label>Audio File:</label>
                        <input type="file" class="source-audio" data-index="${i}" accept="audio/*">
                        <span class="audio-status-${i}" style="font-size: 10px; color: #888;">
                            ${source.audioBuffer ? '✓ Loaded' : 'No audio'}
                        </span>
                    </div>
                `;
                
                list.appendChild(item);
            }
            
            // Attach event listeners
            document.querySelectorAll('.source-name').forEach(input => {
                input.addEventListener('change', (e) => {
                    const index = parseInt(e.target.dataset.index);
                    state.sources[index].id = e.target.value;
                });
            });
            
            document.querySelectorAll('.source-audio').forEach(input => {
                input.addEventListener('change', async (e) => {
                    const index = parseInt(e.target.dataset.index);
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    try {
                        // Ensure audio context exists
                        if (!state.audioCtx) {
                            initAudio();
                        }
                        
                        const arrayBuffer = await file.arrayBuffer();
                        const audioBuffer = await state.audioCtx.decodeAudioData(arrayBuffer);
                        state.sources[index].audioBuffer = audioBuffer;
                        document.querySelector(`.audio-status-${index}`).textContent = '✓ Loaded';
                        
                        if (state.isPlaying) {
                            startSource(state.sources[index]);
                        }
                    } catch (err) {
                        console.error('Failed to decode audio:', err);
                        document.querySelector(`.audio-status-${index}`).textContent = '✗ Error';
                    }
                });
            });
            
            document.querySelectorAll('.delete-source').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const index = parseInt(e.target.dataset.index);
                    const source = state.sources[index];
                    if (source.sourceNode) {
                        source.sourceNode.stop();
                    }
                    state.sources.splice(index, 1);
                    updateSourcesList();
                });
            });
        }
        
        // Canvas interaction with proper coordinate transform
        canvas.addEventListener('mousedown', (e) => {
            // Don't allow drag if tracking is enabled (unless manual mode)
            if (state.tracking.enabled && state.tracking.mode !== 'manual') {
                return;
            }
            
            // Check if clicking "start the experience.." button
            if (state.loadingProgress.showListenButton) {
                const rect = canvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;
                const canvasWidth = canvas.width;
                const canvasHeight = canvas.height;
                const centerX = canvasWidth / 2;
                const centerY = canvasHeight / 2;
                
                // Measure text to determine clickable area
                const buttonText = 'START THE EXPERIENCE';
                // Use Raleway font (thin, elegant)
                ctx.font = '300 32px "Raleway", Raleway, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const textMetrics = ctx.measureText(buttonText);
                const textWidth = textMetrics.width;
                const textHeight = 32; // Approximate text height
                const padding = 10; // Clickable padding around text
                const buttonX = centerX - textWidth / 2 - padding;
                const buttonY = centerY - textHeight / 2 - padding;
                const buttonWidth = textWidth + padding * 2;
                const buttonHeight = textHeight + padding * 2;
                
                // Check if click is within button bounds
                if (clickX >= buttonX && clickX <= buttonX + buttonWidth &&
                    clickY >= buttonY && clickY <= buttonY + buttonHeight) {
                    // Start button fade out (3 seconds)
                    const startButtonOpacity = state.loadingProgress.buttonOpacity || 1;
                    const buttonStartTime = performance.now();
                    const buttonFadeOutDuration = 3000; // 3 seconds
                    
                    const buttonFadeOut = (currentTime) => {
                        const elapsed = currentTime - buttonStartTime;
                        const progress = Math.min(elapsed / buttonFadeOutDuration, 1);
                        state.loadingProgress.buttonOpacity = startButtonOpacity * (1 - progress);
                        draw();
                        
                        if (progress < 1) {
                            requestAnimationFrame(buttonFadeOut);
                        } else {
                            // Button fade complete, hide button
                            state.loadingProgress.buttonOpacity = 0;
                            state.loadingProgress.showListenButton = false;
                            draw();
                        }
                    };
                    
                    requestAnimationFrame(buttonFadeOut);
                    
                    // Fade out overlay over 4 seconds
                    const startOpacity = state.loadingProgress.overlayOpacity || 0.7;
                    const startTime = performance.now();
                    const duration = 4000; // 4 seconds
                    
                    const fadeOut = (currentTime) => {
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        state.loadingProgress.overlayOpacity = startOpacity * (1 - progress);
                        draw();
                        
                        if (progress < 1) {
                            requestAnimationFrame(fadeOut);
                        } else {
                            // Fade complete, hide overlay completely
                            state.loadingProgress.overlayOpacity = 0;
                            draw();
                        }
                    };
                    
                    requestAnimationFrame(fadeOut);
                    
                    // Resume audio context and start playback
                    if (state.audioCtx && state.audioCtx.state === 'suspended') {
                        state.audioCtx.resume().then(() => {
                            console.log('[Start Button] Audio context resumed');
                            startAudio();
                        }).catch(err => {
                            console.warn('[Start Button] Failed to resume:', err);
                        });
                    } else {
                        startAudio();
                    }
                    return; // Don't process other click actions
                }
            }
            
            // Handle audio context resume on first user interaction (for autoplay policy)
            // Note: Audio will only start when Start button is pressed, not on general user interaction
            if (state.audioCtx && state.audioCtx.state === 'suspended' && !state.isPlaying) {
                // Just resume audio context, don't start audio automatically
                state.audioCtx.resume().then(() => {
                    console.log('[User Interaction] Audio context resumed (audio will start when Start button is pressed)');
                }).catch(err => {
                    console.warn('[User Interaction] Failed to resume:', err);
                });
            }
            
            const world = screenToWorld(e.clientX, e.clientY);
            const { x, y } = world;
            
            // Check if clicking listener (increase touch area for easier tapping)
            const listenerDist = distance(x, y, state.listener.x, state.listener.y);
            const touchRadius = 20; // Increased from 10 to 20 for easier touch on mobile
            if (listenerDist < touchRadius) {
                state.dragging = { x, y };
                state.dragType = 'listener';
                // Calculate and store radius from ring center if snap to rings is enabled
                if (state.snapToRings) {
                    const dx = state.listener.x - state.ringCenter.x;
                    const dy = state.listener.y - state.ringCenter.y;
                    state.dragStartRadius = Math.sqrt(dx * dx + dy * dy);
                } else {
                    state.dragStartRadius = null;
                }
                canvas.style.cursor = 'grabbing';
                console.log('[Mouse] Started dragging listener at', x, y);
                return;
            }
            
            // Check if clicking a source (only if not locked)
            if (!state.lockSourcePositions) {
                for (let i = 0; i < state.sources.length; i++) {
                    const source = state.sources[i];
                    // Skip T1 and X1 - they move automatically
                    if (source.id === 'T1' || source.id === 'X1') continue;
                    const dist = distance(x, y, source.x, source.y);
                    if (dist < 10) {
                        state.dragging = { x, y };
                        state.dragType = i;
                        // Calculate and store radius from ring center if snap to rings is enabled
                        if (state.snapToRings) {
                            const dx = source.x - state.ringCenter.x;
                            const dy = source.y - state.ringCenter.y;
                            state.dragStartRadius = Math.sqrt(dx * dx + dy * dy);
                        } else {
                            state.dragStartRadius = null;
                        }
                        canvas.style.cursor = 'grabbing';
                        return;
                    }
                }
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (state.dragging === null || state.dragType === null) {
                // Update cursor on hover
                const rect = canvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;
                const canvasWidth = canvas.width;
                const canvasHeight = canvas.height;
                
                // Check if hovering over button
                if (state.loadingProgress.showListenButton) {
                    const centerX = canvasWidth / 2;
                    const centerY = canvasHeight / 2;
                    const buttonText = 'START THE EXPERIENCE';
                    ctx.font = '300 32px "Raleway", Raleway, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const textMetrics = ctx.measureText(buttonText);
                    const textWidth = textMetrics.width;
                    const textHeight = 32;
                    const padding = 10;
                    const buttonX = centerX - textWidth / 2 - padding;
                    const buttonY = centerY - textHeight / 2 - padding;
                    const buttonWidth = textWidth + padding * 2;
                    const buttonHeight = textHeight + padding * 2;
                    
                    if (clickX >= buttonX && clickX <= buttonX + buttonWidth &&
                        clickY >= buttonY && clickY <= buttonY + buttonHeight) {
                        canvas.style.cursor = 'pointer';
                        return;
                    }
                }
                
                const world = screenToWorld(e.clientX, e.clientY);
                const { x, y } = world;
                
                let hovering = false;
                const listenerDist = distance(x, y, state.listener.x, state.listener.y);
                if (listenerDist < 10) {
                    canvas.style.cursor = 'grab';
                    hovering = true;
                } else {
                    for (const source of state.sources) {
                        const dist = distance(x, y, source.x, source.y);
                        if (dist < 10) {
                            // In listener mode (showSources false), show crosshair on sources
                            if (!state.showSources) {
                                canvas.style.cursor = 'crosshair';
                            } else {
                                canvas.style.cursor = 'grab';
                            }
                            hovering = true;
                            break;
                        }
                    }
                }
                if (!hovering) {
                    canvas.style.cursor = 'crosshair';
                }
                return;
            }
            
            const rect = canvas.getBoundingClientRect();
            const world = screenToWorld(e.clientX - rect.left, e.clientY - rect.top);
            let { x, y } = world;
            
            x = clamp(x, 0, state.worldSize);
            y = clamp(y, 0, state.worldSize);
            
            if (state.dragType === 'listener') {
                state.listener.x = x;
                state.listener.y = y;
            } else if (typeof state.dragType === 'number') {
                // Skip T1 and X1 - they move automatically
                const source = state.sources[state.dragType];
                if (source && source.id !== 'T1' && source.id !== 'X1') {
                    // Use fixed radius from drag start for snap to rings (only angle changes)
                    const snapped = snapToNearestRing(x, y, true);
                    source.x = snapped.x;
                    source.y = snapped.y;
                    updateSourcesList();
                }
            }
            
            draw();
        });
        
        canvas.addEventListener('mouseup', () => {
            state.dragging = null;
            state.dragType = null;
            state.dragStartRadius = null;
            canvas.style.cursor = 'crosshair';
        });
        
        canvas.addEventListener('mouseleave', () => {
            state.dragging = null;
            state.dragType = null;
            state.dragStartRadius = null;
            canvas.style.cursor = 'crosshair';
        });
        
        
        // Touch events for mobile devices
        function getTouchCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0] || e.changedTouches[0];
            return {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };
        }
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent scrolling
            const coords = getTouchCoordinates(e);
            
            // Check if clicking the start button first
            if (state.loadingProgress.showListenButton) {
                const canvasWidth = canvas.width;
                const canvasHeight = canvas.height;
                const centerX = canvasWidth / 2;
                const centerY = canvasHeight / 2;
                const buttonText = 'START THE EXPERIENCE';
                ctx.font = '300 32px "Raleway", Raleway, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const textMetrics = ctx.measureText(buttonText);
                const textWidth = textMetrics.width;
                const textHeight = 32;
                const padding = 10;
                const buttonX = centerX - textWidth / 2 - padding;
                const buttonY = centerY - textHeight / 2 - padding;
                const buttonWidth = textWidth + padding * 2;
                const buttonHeight = textHeight + padding * 2;
                
                if (coords.x >= buttonX && coords.x <= buttonX + buttonWidth &&
                    coords.y >= buttonY && coords.y <= buttonY + buttonHeight) {
                    // Start button clicked - same logic as mouse click
                    const startButtonOpacity = state.loadingProgress.buttonOpacity || 1;
                    const buttonStartTime = performance.now();
                    const buttonFadeOutDuration = 3000;
                    
                    const buttonFadeOut = (currentTime) => {
                        const elapsed = currentTime - buttonStartTime;
                        const progress = Math.min(elapsed / buttonFadeOutDuration, 1);
                        state.loadingProgress.buttonOpacity = startButtonOpacity * (1 - progress);
                        draw();
                        
                        if (progress < 1) {
                            requestAnimationFrame(buttonFadeOut);
                        } else {
                            state.loadingProgress.buttonOpacity = 0;
                            state.loadingProgress.showListenButton = false;
                            draw();
                        }
                    };
                    
                    requestAnimationFrame(buttonFadeOut);
                    
                    const startOpacity = state.loadingProgress.overlayOpacity || 0.7;
                    const startTime = performance.now();
                    const duration = 4000;
                    
                    const fadeOut = (currentTime) => {
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        state.loadingProgress.overlayOpacity = startOpacity * (1 - progress);
                        draw();
                        
                        if (progress < 1) {
                            requestAnimationFrame(fadeOut);
                        } else {
                            state.loadingProgress.overlayOpacity = 0;
                            draw();
                        }
                    };
                    
                    requestAnimationFrame(fadeOut);
                    
                    if (state.audioCtx && state.audioCtx.state === 'suspended') {
                        state.audioCtx.resume().then(() => {
                            console.log('[Start Button] Audio context resumed');
                            startAudio();
                        }).catch(err => {
                            console.warn('[Start Button] Failed to resume:', err);
                        });
                    } else {
                        startAudio();
                    }
                    return; // Don't process drag
                }
            }
            
            // Don't allow drag if tracking is enabled (unless manual mode)
            if (state.tracking.enabled && state.tracking.mode !== 'manual') {
                return;
            }
            
            const world = screenToWorld(coords.x, coords.y);
            const { x, y } = world;
            
            // Check if touching listener (increase touch area for easier tapping on mobile)
            const listenerDist = distance(x, y, state.listener.x, state.listener.y);
            const touchRadius = 20; // Increased from 10 to 20 for easier touch on mobile
            if (listenerDist < touchRadius) {
                state.dragging = { x: coords.x, y: coords.y };
                state.dragType = 'listener';
                const dx = state.listener.x - state.ringCenter.x;
                const dy = state.listener.y - state.ringCenter.y;
                state.dragStartRadius = Math.sqrt(dx * dx + dy * dy);
                console.log('[Touch] Started dragging listener at', x, y);
            } else {
                console.log('[Touch] Touch too far from listener. Distance:', listenerDist, 'Touch at:', x, y, 'Listener at:', state.listener.x, state.listener.y);
            }
        }, { passive: false });
        
        canvas.addEventListener('touchmove', (e) => {
            if (state.dragging === null || state.dragType === null) return;
            
            e.preventDefault(); // Prevent scrolling
            const coords = getTouchCoordinates(e);
            const world = screenToWorld(coords.x, coords.y);
            let { x, y } = world;
            
            x = clamp(x, 0, state.worldSize);
            y = clamp(y, 0, state.worldSize);
            
            if (state.dragType === 'listener') {
                state.listener.x = x;
                state.listener.y = y;
                console.log('[Touch] Moving listener to', x, y);
            }
            
            draw();
        }, { passive: false });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            state.dragging = null;
            state.dragType = null;
            state.dragStartRadius = null;
        });
        
        canvas.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            state.dragging = null;
            state.dragType = null;
            state.dragStartRadius = null;
        });
        
        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.tab;
                
                // Update tab buttons
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                // Update tab panes
                document.querySelectorAll('.tab-pane').forEach(pane => pane.classList.remove('active'));
                const targetPane = document.getElementById(`tab-${tabName}`);
                if (targetPane) {
                    targetPane.classList.add('active');
                }
                
                // Update mixer list when mixer tab is opened
                if (tabName === 'mixer') {
                    updateMixerList();
                }
                
                // Update canvas size in case tab height changed
                updateCanvasSize();
            });
        });
        
        // Panel collapse
        const panelHeader = document.getElementById('panel-header');
        if (panelHeader) {
            panelHeader.addEventListener('click', () => {
                const panel = document.getElementById('control-panel');
                const toggle = document.getElementById('collapse-toggle');
                if (panel && toggle) {
                    panel.classList.toggle('collapsed');
                    // For right-side panel: ▶ when collapsed (can expand), ◀ when expanded (can collapse)
                    toggle.textContent = panel.classList.contains('collapsed') ? '▶' : '◀';
                    // Recalculate canvas size after collapse/expand
                    setTimeout(() => {
                        updateCanvasSize();
                    }, 300); // Wait for transition
                }
            });
        }
        
        // UI Event Listeners
        // HUD controls (always visible)
        const hudStartBtn = document.getElementById('hudStartBtn');
        const hudStopBtn = document.getElementById('hudStopBtn');
        if (hudStartBtn) hudStartBtn.addEventListener('click', startAudio);
        if (hudStopBtn) hudStopBtn.addEventListener('click', stopAudio);
        
        // Tab controls
        // Master volume fader removed - volume is controlled programmatically
        // Master volume fader removed - volume is controlled programmatically
        // (fade in from -60 dB to 0 dB on start, etc.)
        
        // Compressor controls
        const compressorEnabledCheckbox = document.getElementById('compressorEnabled');
        if (compressorEnabledCheckbox) {
            compressorEnabledCheckbox.addEventListener('change', (e) => {
                const enabled = e.target.checked;
                state.compressorEnabled = enabled;
                toggleCompressor(enabled);
            });
        }
        
        const compressorThreshold = document.getElementById('compressorThreshold');
        if (compressorThreshold) {
            compressorThreshold.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                const valueDisplay = document.getElementById('compressorThresholdValue');
                if (valueDisplay) valueDisplay.textContent = value;
                if (state.masterCompressor) {
                    // Store current makeup gain to prevent auto-adjustment
                    const currentMakeupGain = state.masterMakeupGain ? state.masterMakeupGain.gain.value : dbToLin(4);
                    state.masterCompressor.threshold.value = value;
                    // Ensure makeup gain stays constant (no auto-adjustment)
                    if (state.masterMakeupGain) {
                        state.masterMakeupGain.gain.value = currentMakeupGain;
                    }
                }
            });
        }
        
        const compressorRatio = document.getElementById('compressorRatio');
        if (compressorRatio) {
            compressorRatio.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                const valueDisplay = document.getElementById('compressorRatioValue');
                if (valueDisplay) valueDisplay.textContent = value;
                if (state.masterCompressor) {
                    state.masterCompressor.ratio.value = value;
                }
            });
        }
        
        const compressorAttack = document.getElementById('compressorAttack');
        if (compressorAttack) {
            compressorAttack.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                const valueDisplay = document.getElementById('compressorAttackValue');
                if (valueDisplay) valueDisplay.textContent = value;
                if (state.masterCompressor) {
                    state.masterCompressor.attack.value = value / 1000; // Convert ms to seconds
                }
            });
        }
        
        const compressorRelease = document.getElementById('compressorRelease');
        if (compressorRelease) {
            compressorRelease.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                const valueDisplay = document.getElementById('compressorReleaseValue');
                if (valueDisplay) valueDisplay.textContent = value;
                if (state.masterCompressor) {
                    state.masterCompressor.release.value = value / 1000; // Convert ms to seconds
                }
            });
        }
        
        const compressorMakeup = document.getElementById('compressorMakeup');
        if (compressorMakeup) {
            compressorMakeup.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                const valueDisplay = document.getElementById('compressorMakeupValue');
                if (valueDisplay) valueDisplay.textContent = value;
                if (state.masterMakeupGain) {
                    state.masterMakeupGain.gain.value = dbToLin(value);
                }
            });
        }
        
        const nearestNTab = document.getElementById('nearestN');
        if (nearestNTab) {
            nearestNTab.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                state.nearestN = value;
                const valueDisplay = document.getElementById('nearestNValue');
                if (valueDisplay) valueDisplay.textContent = value;
            });
        }
        
        const globalRmaxTab = document.getElementById('globalRmax');
        if (globalRmaxTab) {
            globalRmaxTab.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                state.globalRmax = value;
                const valueDisplay = document.getElementById('globalRmaxValue');
                if (valueDisplay) valueDisplay.textContent = value;
                // Update sources without custom rmax
                for (const source of state.sources) {
                    if (source.rmax === state.globalRmax || Math.abs(source.rmax - state.globalRmax) < 1) {
                        source.rmax = value;
                    }
                }
                updateSourcesList();
            });
        }
        
        const falloffPowerTab = document.getElementById('falloffPower');
        if (falloffPowerTab) {
            falloffPowerTab.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                state.falloffPower = value;
                const valueDisplay = document.getElementById('falloffPowerValue');
                if (valueDisplay) valueDisplay.textContent = value.toFixed(1);
                for (const source of state.sources) {
                    source.falloffPower = value;
                }
            });
        }
        
        const panningEnabled = document.getElementById('panningEnabled');
        if (panningEnabled) {
            panningEnabled.addEventListener('change', (e) => {
                state.panningEnabled = e.target.checked;
            });
        }
        
        const panDistance = document.getElementById('panDistance');
        if (panDistance) {
            panDistance.addEventListener('input', (e) => {
                state.panDistance = parseFloat(e.target.value);
                const valueDisplay = document.getElementById('panDistanceValue');
                if (valueDisplay) valueDisplay.textContent = state.panDistance;
            });
        }
        
        const showSourceRanges = document.getElementById('showSourceRanges');
        if (showSourceRanges) {
            showSourceRanges.addEventListener('change', (e) => {
                state.showSourceRanges = e.target.checked;
            });
        }
        
        const snapToRings = document.getElementById('snapToRings');
        if (snapToRings) {
            snapToRings.addEventListener('change', (e) => {
                state.snapToRings = e.target.checked;
            });
        }
        
        const debugVisuals = document.getElementById('debugVisuals');
        if (debugVisuals) {
            debugVisuals.addEventListener('change', (e) => {
                state.debugVisuals = e.target.checked;
            });
        }
        
        const showSources = document.getElementById('showSources');
        if (showSources) {
            showSources.addEventListener('change', (e) => {
                state.showSources = e.target.checked;
            });
        }
        
        const showSourceLabels = document.getElementById('showSourceLabels');
        if (showSourceLabels) {
            showSourceLabels.addEventListener('change', (e) => {
                state.showSourceLabels = e.target.checked;
            });
        }
        
        const lockSourcePositions = document.getElementById('lockSourcePositions');
        if (lockSourcePositions) {
            lockSourcePositions.addEventListener('change', (e) => {
                state.lockSourcePositions = e.target.checked;
            });
        }
        
        // Preset system
        function applyPreset(presetName) {
            if (presetName === 'designer') {
                // Designer Mode preset
                state.showSources = true;
                state.showSourceRanges = true;
                state.lockSourcePositions = true;
                state.snapToRings = true;
                state.showSourceLabels = false;
                state.currentPreset = 'designer';
            } else if (presetName === 'listener') {
                // Listener Mode preset
                state.showSources = false;
                state.showSourceRanges = false;
                state.lockSourcePositions = true;
                state.snapToRings = true;
                state.showSourceLabels = false;
                state.currentPreset = 'listener';
            }
            
            // Update UI checkboxes
            if (showSources) showSources.checked = state.showSources;
            if (showSourceRanges) showSourceRanges.checked = state.showSourceRanges;
            if (lockSourcePositions) lockSourcePositions.checked = state.lockSourcePositions;
            if (snapToRings) snapToRings.checked = state.snapToRings;
            if (showSourceLabels) showSourceLabels.checked = state.showSourceLabels;
            
            // Update preset radio buttons
            const presetListener = document.getElementById('presetListener');
            const presetDesigner = document.getElementById('presetDesigner');
            if (presetListener) presetListener.checked = (presetName === 'listener');
            if (presetDesigner) presetDesigner.checked = (presetName === 'designer');
        }
        
        // Preset radio buttons
        const presetListener = document.getElementById('presetListener');
        const presetDesigner = document.getElementById('presetDesigner');
        if (presetListener) {
            presetListener.addEventListener('change', (e) => {
                if (e.target.checked) {
                    applyPreset('listener');
                }
            });
        }
        if (presetDesigner) {
            presetDesigner.addEventListener('change', (e) => {
                if (e.target.checked) {
                    applyPreset('designer');
                }
            });
        }
        
        // Initialize with Listener Mode preset (default)
        applyPreset('listener');
        
        // Load audio file and save to localStorage
        async function loadAndSaveAudioFile(file, sourceIndex, sourceId) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                
                // Convert to base64 for localStorage (chunked to avoid stack overflow)
                const bytes = new Uint8Array(arrayBuffer);
                let binary = '';
                const chunkSize = 8192; // Process in chunks
                for (let i = 0; i < bytes.length; i += chunkSize) {
                    const chunk = bytes.subarray(i, i + chunkSize);
                    binary += String.fromCharCode.apply(null, chunk);
                }
                const base64 = btoa(binary);
                const dataUrl = `data:${file.type};base64,${base64}`;
                
                // Save to localStorage
                try {
                    localStorage.setItem(`audio_${sourceId}`, dataUrl);
                    localStorage.setItem(`audio_${sourceId}_type`, file.type);
                    console.log(`[Load All] Saved ${sourceId} to localStorage`);
                } catch (err) {
                    console.warn(`[Load All] Failed to save ${sourceId} to localStorage:`, err);
                }
                
                // Load into audio context
                if (state.audioCtx) {
                    const audioBuffer = await state.audioCtx.decodeAudioData(arrayBuffer);
                    state.sources[sourceIndex].audioBuffer = audioBuffer;
                    
                    // If audio is playing, start this source
                    if (state.isPlaying) {
                        startSource(state.sources[sourceIndex]);
                    }
                }
                
                return true;
            } catch (err) {
                console.error(`[Load All] ✗ Failed to load ${file.name}:`, err);
                return false;
            }
        }
        
        // Load audio from localStorage
        async function loadAudioFromLocalStorage(sourceIndex, sourceId) {
            try {
                const dataUrl = localStorage.getItem(`audio_${sourceId}`);
                if (!dataUrl) {
                    return false;
                }
                
                // Ensure audio context exists
                if (!state.audioCtx) {
                    try {
                        initAudio();
                    } catch (err) {
                        console.warn(`[Auto-load] Could not init audio context for ${sourceId}:`, err);
                        return false;
                    }
                }
                
                if (!state.audioCtx) {
                    return false;
                }
                
                // Convert data URL to ArrayBuffer
                const response = await fetch(dataUrl);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await state.audioCtx.decodeAudioData(arrayBuffer);
                state.sources[sourceIndex].audioBuffer = audioBuffer;
                
                console.log(`[Auto-load] ✓ Loaded ${sourceId} from localStorage`);
                return true;
            } catch (err) {
                console.warn(`[Auto-load] Failed to load ${sourceId} from localStorage:`, err);
                // Remove corrupted data
                localStorage.removeItem(`audio_${sourceId}`);
                localStorage.removeItem(`audio_${sourceId}_type`);
                return false;
            }
        }
        
        // Load all audio files and match with sources
        const loadAllAudioFiles = document.getElementById('loadAllAudioFiles');
        if (loadAllAudioFiles) {
            loadAllAudioFiles.addEventListener('change', async (e) => {
                const files = Array.from(e.target.files);
                if (files.length === 0) return;
                
                // Ensure audio context exists
                if (!state.audioCtx) {
                    try {
                        initAudio();
                    } catch (err) {
                        console.error('Failed to init audio context:', err);
                        alert('Failed to initialize audio. Please try clicking Start Audio first.');
                        return;
                    }
                }
                
                if (!state.audioCtx) {
                    alert('Audio context not available. Please click Start Audio first.');
                    return;
                }
                
                console.log(`[Load All] Processing ${files.length} files...`);
                let loadedCount = 0;
                
                for (const file of files) {
                    // Extract base name without extension (e.g., "A1" from "A1.mp3")
                    const baseName = file.name.replace(/\.[^/.]+$/, '');
                    
                    // Find matching source by ID
                    const sourceIndex = state.sources.findIndex(s => s.id === baseName);
                    
                    if (sourceIndex !== -1) {
                        const success = await loadAndSaveAudioFile(file, sourceIndex, baseName);
                        if (success) {
                            console.log(`[Load All] ✓ Loaded ${baseName}: ${file.name}`);
                            loadedCount++;
                        }
                    } else {
                        console.log(`[Load All] No matching source found for ${baseName} (from ${file.name})`);
                    }
                }
                
                updateSourcesList();
                console.log(`[Load All] Finished: ${loadedCount}/${files.length} files loaded and saved`);
                
                // Clear input so same files can be selected again if needed
                e.target.value = '';
            });
        }
        
        // Load audio file and save to localStorage
        async function loadAndSaveAudioFile(file, sourceIndex, sourceId) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                
                // Convert to base64 for localStorage (chunked to avoid stack overflow)
                const bytes = new Uint8Array(arrayBuffer);
                let binary = '';
                const chunkSize = 8192; // Process in chunks
                for (let i = 0; i < bytes.length; i += chunkSize) {
                    const chunk = bytes.subarray(i, i + chunkSize);
                    binary += String.fromCharCode.apply(null, chunk);
                }
                const base64 = btoa(binary);
                const dataUrl = `data:${file.type};base64,${base64}`;
                
                // Save to localStorage
                try {
                    localStorage.setItem(`audio_${sourceId}`, dataUrl);
                    localStorage.setItem(`audio_${sourceId}_type`, file.type);
                    console.log(`[Load All] Saved ${sourceId} to localStorage`);
                } catch (err) {
                    console.warn(`[Load All] Failed to save ${sourceId} to localStorage:`, err);
                }
                
                // Load into audio context
                if (state.audioCtx) {
                    const audioBuffer = await state.audioCtx.decodeAudioData(arrayBuffer);
                    state.sources[sourceIndex].audioBuffer = audioBuffer;
                    
                    // If audio is playing, start this source
                    if (state.isPlaying) {
                        startSource(state.sources[sourceIndex]);
                    }
                }
                
                return true;
            } catch (err) {
                console.error(`[Load All] ✗ Failed to load ${file.name}:`, err);
                return false;
            }
        }
        
        // Load audio from localStorage
        async function loadAudioFromLocalStorage(sourceIndex, sourceId) {
            try {
                const dataUrl = localStorage.getItem(`audio_${sourceId}`);
                if (!dataUrl) {
                    return false;
                }
                
                // Ensure audio context exists
                if (!state.audioCtx) {
                    try {
                        initAudio();
                    } catch (err) {
                        console.warn(`[Auto-load] Could not init audio context for ${sourceId}:`, err);
                        return false;
                    }
                }
                
                if (!state.audioCtx) {
                    return false;
                }
                
                // Convert data URL to ArrayBuffer
                const response = await fetch(dataUrl);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await state.audioCtx.decodeAudioData(arrayBuffer);
                state.sources[sourceIndex].audioBuffer = audioBuffer;
                
                console.log(`[Auto-load] ✓ Loaded ${sourceId} from localStorage`);
                return true;
            } catch (err) {
                console.warn(`[Auto-load] Failed to load ${sourceId} from localStorage:`, err);
                // Remove corrupted data
                localStorage.removeItem(`audio_${sourceId}`);
                localStorage.removeItem(`audio_${sourceId}_type`);
                return false;
            }
        }
        
        const debugOverlay = document.getElementById('debugOverlay');
        if (debugOverlay) {
            debugOverlay.addEventListener('change', (e) => {
                state.debugOverlayVisible = e.target.checked;
                const overlay = document.getElementById('debug-overlay');
                if (overlay) {
                    if (state.debugOverlayVisible) {
                        overlay.classList.add('visible');
                    } else {
                        overlay.classList.remove('visible');
                    }
                }
            });
        }
        
        // Tracking mode selector
        const trackingMode = document.getElementById('trackingMode');
        if (trackingMode) {
            trackingMode.addEventListener('change', (e) => {
                const mode = e.target.value;
                state.tracking.mode = mode;
                
                // Disable tracking if switching modes
                if (state.tracking.enabled) {
                    disableDeviceMotionTracking();
                }
                
                // Enable tracking checkbox based on mode
                const enableCheckbox = document.getElementById('enableTracking');
                if (enableCheckbox) {
                    enableCheckbox.disabled = (mode === 'arkit');
                    if (mode === 'arkit') {
                        enableCheckbox.checked = false;
                        state.tracking.enabled = false;
                        updateTrackingStatus('ARKit requires native iOS app', false);
                    }
                }
            });
        }
        
        // Enable/disable tracking checkbox
        const enableTracking = document.getElementById('enableTracking');
        if (enableTracking) {
            enableTracking.addEventListener('change', (e) => {
                if (e.target.checked) {
                    if (state.tracking.mode === 'devicemotion') {
                        enableDeviceMotionTracking();
                    } else if (state.tracking.mode === 'manual') {
                        state.tracking.enabled = false;
                        updateTrackingStatus('Manual mode - drag to move', false);
                    } else if (state.tracking.mode === 'arkit') {
                        updateTrackingStatus('ARKit requires native iOS app', false);
                        e.target.checked = false;
                    }
                } else {
                    if (state.tracking.mode === 'devicemotion') {
                        disableDeviceMotionTracking();
                    } else {
                        state.tracking.enabled = false;
                        updateTrackingStatus('Disabled', false);
                    }
                }
            });
        }
        
        const applyRingsBtn = document.getElementById('applyRingsBtn');
        if (applyRingsBtn) {
            applyRingsBtn.addEventListener('click', () => {
                const input = document.getElementById('ringRadiiInput');
                if (input) {
                    const radii = input.value.split(',').map(s => parseFloat(s.trim())).filter(n => !isNaN(n) && n > 0);
                    if (radii.length > 0) {
                        state.ringRadii = radii.sort((a, b) => a - b);
                    }
                }
            });
        }
        
        const addSourceBtn = document.getElementById('addSourceBtn');
        if (addSourceBtn) {
            addSourceBtn.addEventListener('click', () => {
                const newPos = snapToNearestRing(120, 120);
                // Generate next name: if we have A1-A4, B1-B4, next would be C1, C2, etc.
                const groupIndex = Math.floor(state.sources.length / 4);
                const itemIndex = (state.sources.length % 4) + 1;
                const groupLetter = String.fromCharCode(65 + groupIndex); // A, B, C, ...
                const newId = `${groupLetter}${itemIndex}`;
                
                state.sources.push({
                    id: newId,
                    x: newPos.x,
                    y: newPos.y,
                    audioBuffer: null,
                    sourceNode: null,
                    gainNode: null,
                    pannerNode: null,
                    rmax: state.globalRmax,
                    falloffPower: state.falloffPower,
                    gainSmoothness: 0.05, // Gain fade smoothness (time constant in seconds)
                    muted: false,
                    solo: false,
                    visualAlpha: 0,
                });
                updateSourcesList();
            });
        }
        
        // Background image controls
        const reloadBgBtn = document.getElementById('reloadBgBtn');
        if (reloadBgBtn) {
            reloadBgBtn.addEventListener('click', () => {
                if (isFileProtocol) {
                    // file:// mode: cannot reload by filename
                    state.bgImage.status = 'ERROR';
                    state.bgImage.errorMessage = 'file:// mode cannot reload by filename. Please choose the image once via file picker or run a local server.';
                    updateBgStatus();
                    
                    // Highlight file input
                    const fileInput = document.getElementById('bgImageFile');
                    if (fileInput) {
                        fileInput.style.border = '2px solid #04427b';
                        fileInput.style.animation = 'shake 0.5s';
                        setTimeout(() => {
                            fileInput.style.border = '';
                            fileInput.style.animation = '';
                        }, 500);
                    }
                    return;
                }
                
                // http:// mode: normal reload
                const urlInput = document.getElementById('bgImageUrl');
                if (urlInput) {
                    const url = urlInput.value.trim();
                    const srcToLoad = url || DEFAULT_BG_SRC;
                    if (url !== srcToLoad) {
                        urlInput.value = srcToLoad;
                    }
                    loadBgImage(srcToLoad, true);
                }
            });
        }
        
        const bgImageUrl = document.getElementById('bgImageUrl');
        if (bgImageUrl) {
            bgImageUrl.addEventListener('change', (e) => {
                if (isFileProtocol) {
                    // In file:// mode, URL input is read-only (for display)
                    // User must use file picker
                    return;
                }
                const url = e.target.value.trim();
                if (url) {
                    loadBgImage(url, false);
                }
            });
        }
        
        const bgImageFile = document.getElementById('bgImageFile');
        if (bgImageFile) {
            bgImageFile.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                if (!file.type.startsWith('image/')) {
                    alert('Please select an image file');
                    e.target.value = '';
                    return;
                }
                
                state.bgImage.src = file.name;
                state.bgImage.status = 'LOADING';
                updateBgStatus();
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    const dataUrl = event.target.result;
                    const img = state.bgImage.image;
                    if (!img) {
                        console.error('Background image object not initialized');
                        return;
                    }
                    
                    // Save to localStorage for file:// persistence
                    try {
                        localStorage.setItem('bgDataUrl', dataUrl);
                        localStorage.setItem('bgFileName', file.name);
                    } catch (err) {
                        console.warn('Failed to save to localStorage:', err);
                    }
                    
                    img.src = dataUrl;
                };
                reader.onerror = () => {
                    state.bgImage.status = 'ERROR';
                    state.bgImage.errorMessage = `Failed to read file: ${file.name}`;
                    updateBgStatus();
                    console.error('File read error:', file.name);
                };
                reader.readAsDataURL(file);
            });
        }
        
        // Window resize handler
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                updateCanvasSize();
            }, 100);
        });
        
        
        // Initialize - correct order
        // 1. Initialize the ONE canonical background image object
        initBgImage();
        
        // 2. Update canvas size BEFORE first draw (ensures valid scale)
        updateCanvasSize();
        
        // 3. Initialize default sources
        initDefaultSources();
        
        // 3a. Auto-load audio files from localStorage (if previously saved)
        async function loadAllAudioFromStorage() {
            console.log('[Auto-load] Checking localStorage for saved audio files...');
            let loadedCount = 0;
            
            // Wait a bit for audio context to be ready
            await new Promise(resolve => setTimeout(resolve, 200));
            
            for (let i = 0; i < state.sources.length; i++) {
                const source = state.sources[i];
                if (!source.audioBuffer) {
                    const loaded = await loadAudioFromLocalStorage(i, source.id);
                    if (loaded) {
                        loadedCount++;
                    }
                    // Small delay between loads
                    await new Promise(resolve => setTimeout(resolve, 20));
                }
            }
            
            if (loadedCount > 0) {
                console.log(`[Auto-load] Loaded ${loadedCount} audio files from localStorage`);
                updateSourcesList();
                
                // Show "Listen!" button after loading completes
                // Set showListenButton first to ensure overlay stays visible, then hide loading bar
                // Use requestAnimationFrame to ensure smooth transition without flash
                requestAnimationFrame(() => {
                    state.loadingProgress.showListenButton = true;
                    // Ensure overlay opacity is set for fade out later
                    if (state.loadingProgress.overlayOpacity === undefined) {
                        state.loadingProgress.overlayOpacity = 0.7;
                    }
                    // Start button fade in (2 seconds)
                    state.loadingProgress.buttonOpacity = 0;
                    const startTime = performance.now();
                    const fadeInDuration = 2000; // 2 seconds
                    
                    const fadeIn = (currentTime) => {
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / fadeInDuration, 1);
                        state.loadingProgress.buttonOpacity = progress;
                        draw();
                        
                        if (progress < 1) {
                            requestAnimationFrame(fadeIn);
                        } else {
                            state.loadingProgress.buttonOpacity = 1;
                            draw();
                        }
                    };
                    
                    requestAnimationFrame(fadeIn);
                    
                    // Loading background GIF is already visible from loading bar phase
                    draw(); // Draw with button visible and loading bar still showing
                    requestAnimationFrame(() => {
                        state.loadingProgress.isLoading = false;
                        draw(); // Now hide loading bar, overlay stays because showListenButton is true
                    });
                });
            } else {
                console.log('[Auto-load] No saved audio files found in localStorage');
                // Hide loading bar even if no files loaded
                state.loadingProgress.isLoading = false;
            }
        }
        
        // Start loading from localStorage immediately
        // Disabled: User loads audio files manually
        // loadAllAudioFromStorage();
        
        // 3b. Auto-load audio files matching source names (http:// only)
        autoLoadAllSourceAudio();
        
        // 4. Initialize debug display
        const debugSrc = document.getElementById('bgDebugSrc');
        if (debugSrc) {
            debugSrc.textContent = DEFAULT_BG_SRC;
        }
        updateBgStatus(); // Set initial status display
        
        // 5. Load background image based on protocol
        if (isFileProtocol) {
            // file:// mode: try localStorage first
            try {
                const storedDataUrl = localStorage.getItem('bgDataUrl');
                const storedFileName = localStorage.getItem('bgFileName') || '(local)';
                
                if (storedDataUrl) {
                    const img = state.bgImage.image;
                    if (img) {
                        state.bgImage.src = storedFileName;
                        state.bgImage.status = 'LOADING';
                        const urlInput = document.getElementById('bgImageUrl');
                        if (urlInput) {
                            urlInput.value = storedFileName;
                        }
                        updateBgStatus();
                        // Set src - onload handler will update status and trigger draw
                        img.src = storedDataUrl;
                        // If image is already cached/loaded (data URL loads instantly), onload might not fire
                        // Check after a microtask
                        setTimeout(() => {
                            if (img.complete && img.naturalWidth > 0 && state.bgImage.status === 'LOADING') {
                                // Image already loaded, trigger onload manually
                                img.onload();
                            }
                        }, 0);
                    }
                } else {
                    // No stored image, show warning
                    state.bgImage.status = 'ERROR';
                    state.bgImage.errorMessage = 'No background loaded. Please select an image file.';
                    updateBgStatus();
                }
            } catch (err) {
                console.warn('Failed to load from localStorage:', err);
                state.bgImage.status = 'ERROR';
                state.bgImage.errorMessage = 'Failed to load stored background. Please select an image file.';
                updateBgStatus();
            }
        } else {
            // http:// mode: load default background
            loadBgImage(DEFAULT_BG_SRC, false);
        }
        
        // 5b. Loading background GIF is handled via HTML img element overlay (for animation support)
        
        // 6. Wait for Raleway font to load, then start render loop
        const loadRalewayFont = async () => {
            if (document.fonts && document.fonts.load) {
                try {
                    await document.fonts.load('300 32px Raleway');
                    console.log('Raleway font loaded successfully');
                } catch (err) {
                    console.warn('Raleway font loading failed:', err);
                }
            }
            
            // Wait a bit more to ensure font is ready
            if (document.fonts && document.fonts.ready) {
                await document.fonts.ready;
            }
            
            // Additional delay to ensure font is applied
            setTimeout(() => {
                console.log('Starting render loop');
                renderLoop();
            }, 100);
        };
        
        loadRalewayFont();
        
        // 7. Update audio status
        updateAudioStatus();
        
        // 8. If panel width was invalid, schedule a second updateCanvasSize
        const panel = document.getElementById('control-panel');
        if (panel && panel.offsetWidth <= 0) {
            requestAnimationFrame(() => {
                updateCanvasSize();
            });
        }
    </script>
</body>
</html>
